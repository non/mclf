<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Loser Lane</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div id="game-container">
      <!-- Settings Window -->
      <div id="settings-window">
        <h3>Game Settings</h3>

        <!-- Pedestrian Speed -->
        <label for="pedestrian-speed"
          >Pedestrian Speed
          <span id="pedestrian-speed-value" class="value-display">0.5</span>
        </label>
        <input id="pedestrian-speed" type="range" min="0.1" max="3" step="0.1" value="0.5" />

        <!-- Spawn Rates -->
        <label for="streetcar-spawn-rate"
          >Streetcar Spawn Rate
          <span id="streetcar-spawn-rate-value" class="value-display">0.03</span>
        </label>
        <input id="streetcar-spawn-rate" type="range" min="0.01" max="1" step="0.01" value="0.03" />

        <label for="oncoming-car-spawn-rate"
          >Oncoming Car Spawn Rate
          <span id="oncoming-car-spawn-rate-value" class="value-display">0.15</span>
        </label>
        <input id="oncoming-car-spawn-rate" type="range" min="0.01" max="1" step="0.01" value="0.15" />

        <label for="parked-car-spawn-rate"
          >Parked Car Spawn Rate
          <span id="parked-car-spawn-rate-value" class="value-display">0.05</span>
        </label>
        <input id="parked-car-spawn-rate" type="range" min="0.01" max="1" step="0.01" value="0.15" />

        <label for="streetcar-lane-car-spawn-rate"
          >Streetcar Lane Car Spawn Rate
          <span id="streetcar-lane-car-spawn-rate-value" class="value-display">0.3</span>
        </label>
        <input id="streetcar-lane-car-spawn-rate" type="range" min="0.01" max="1" step="0.01" value="0.3" />

        <label for="pedestrian-spawn-rate"
          >Pedestrian Spawn Rate
          <span id="pedestrian-spawn-rate-value" class="value-display">0.05</span>
        </label>
        <input id="pedestrian-spawn-rate" type="range" min="0.01" max="1" step="0.01" value="0.05" />

        <!-- Game Speed Controls -->
        <label for="initial-speed"
          >Initial Game Speed
          <span id="initial-speed-value" class="value-display">500</span>
        </label>
        <input id="initial-speed" type="range" min="100" max="1000" step="10" value="500" />

        <label for="min-speed"
          >Minimum Game Speed
          <span id="min-speed-value" class="value-display">300</span>
        </label>
        <input id="min-speed" type="range" min="100" max="1000" step="10" value="300" />

        <label for="speed-decrease-rate"
          >Speed Decrease Rate
          <span id="speed-decrease-rate-value" class="value-display">0.995</span>
        </label>
        <input id="speed-decrease-rate" type="range" min="0.9" max="1" step="0.001" value="0.995" />

        <!-- Gaps Between Vehicles -->
        <label for="streetcar-gap"
          >Streetcar Gap
          <span id="streetcar-gap-value" class="value-display">20</span>
        </label>
        <input id="streetcar-gap" type="range" min="10" max="50" step="1" value="20" />

        <label for="lane-car-gap"
          >Streetcar Lane Car Gap
          <span id="lane-car-gap-value" class="value-display">12</span>
        </label>
        <input id="lane-car-gap" type="range" min="10" max="50" step="1" value="12" />

        <label for="oncoming-car-gap"
          >Oncoming Car Gap
          <span id="oncoming-car-gap-value" class="value-display">8</span>
        </label>
        <input id="oncoming-car-gap" type="range" min="5" max="30" step="1" value="8" />

        <!-- Lane Widths and Cyclist Speed -->
        <label for="lane-width"
          >Lane Width
          <span id="lane-width-value" class="value-display">45</span>
        </label>
        <input id="lane-width" type="range" min="20" max="60" step="1" value="45" />

        <label for="cyclist-speed"
          >Cyclist Speed
          <span id="cyclist-speed-value" class="value-display">100</span>
        </label>
        <input id="cyclist-speed" type="range" min="50" max="200" step="5" value="100" />
      </div>

      <div id="game-screen"></div>
      <div id="mainMessageBox">
        <!-- <span id="gameTitle">L O S E R ~ L A N E</span><br /><br /> -->

        CLICK/SPACEBAR to play <br /><br />
        LEFT/RIGHT arrow keys or TAP sides to move<br /><br />
        DOUBLE-TAP to jump tracks!
      </div>
      <br />
      <div id="controls">
        <div class="control-area" id="move-left"></div>
        <div class="control-area" id="move-right"></div>
      </div>
      <div class="title-box">
        <!-- <div id="title">L O S E R ~ L A N E</div>
        <div id="time-alive">STAY ALIVE 0</div> -->

        <div id="title-box-container">
          <div class="bike-art-left">
            __o <br />
            _ \<_ <br />
            (_)/(_)
          </div>

          <div class="title-text">
            <div id="title">L O S E R âˆž L A N E</div>
            <div id="time-alive">STAY ALIVE! 0</div>
          </div>

          <div class="bike-art-right">
            o__ <br />
            _ >/ _ <br />
            (_) \(_)
          </div>
        </div>
      </div>
    </div>

    <script>
      // Constants and Configuration

      const CONFIG = {
        GAME: {
          WIDTH: 45,
          HEIGHT: Math.floor(window.innerHeight / 20),
          INITIAL_SPEED: 500, // Changed from 20 to match settings window
          MIN_SPEED: 300,
          SPEED_DECREASE_RATE: 0.995,
          CYCLIST_Y: Math.floor(window.innerHeight / 40),
          // DOUBLE_TAP_WINDOW: 500, // Increased from 400ms
          DOUBLE_TAP_TIME: 350,
          // TAP_RESET_DELAY: 600, // Increased from 500ms
          // JUMP_DURATION: 300, // Increased from 200ms
          lastKeys: {
            left: 0,
            right: 0,
          },
          keyPressCount: {
            left: 0,
            right: 0,
          },
        },
        SPAWN_RATES: {
          STREETCAR: 0.03,
          STREETCAR_LANE_CAR: 0.3,
          ONCOMING_CAR: 0.15,
          PARKED_CAR: 0.15,
          DOOR_OPENING: 0.1,
          PEDESTRIAN: 0.05,
          BUILDING: 0.05,
        },
        SAFE_DISTANCE: {
          // Added missing configuration section
          STREETCAR: 15,
          STREETCAR_LANE_CAR: 8,
          ONCOMING_CAR: 6,
          PARKED: 5,
          PEDESTRIAN: 3,
          BUILDING: 0,
        },
        PEDESTRIAN: {
          SPEED: 0.5,
        },
        LANES: {
          ONCOMING: 2,
          DIVIDER: 8,
          TRACKS: 12,
          BIKE: 19,
          BIKE_RIGHT: 20,
          PARKED: 22,
          SIDEWALK: 30,
          SHOPS: 34,
        },
      };

      // Types and Interfaces
      class Position {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }

        equals(other) {
          return this.x === other.x && this.y === other.y;
        }

        distanceTo(other) {
          return Math.sqrt(Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2));
        }
      }

      class EntityType {
        static STREETCAR = "STREETCAR";
        static STREETCAR_LANE_CAR = "STREETCAR_LANE_CAR"; // Changed from current
        static ONCOMING_CAR = "ONCOMING"; // Changed from "CAR"
        static PARKED_CAR = "PARKEDCAR"; // Changed from "PARKED"
        static PEDESTRIAN = "PEDESTRIAN";
        static BUILDING = "BUILDING";
        static PLAYER = "PLAYER";
      }
      // Core Spatial Management System
      class SpatialManager {
        constructor(config) {
          this.config = config;
          this.grid = new GridSystem(config);
          this.collisionManager = new CollisionManager(this);
          this.movementCoordinator = new MovementCoordinator(this);
          this.spawnManager = new SpawnManager(this, config);
          this.entities = new Set();
        }

        update() {
          // Remove off-screen entities
          this.entities.forEach((entity) => {
            if (entity.position.y > this.config.GAME.HEIGHT + 5 || entity.position.y + entity.height < -5) {
              this.unregisterEntity(entity);
            }
          });

          this.movementCoordinator.update();
          this.collisionManager.update();
          this.entities.forEach((entity) => entity.behavior.update());
        }

        validateMove(entity, newPosition) {
          return this.collisionManager.validateMovement(entity, newPosition);
        }

        registerEntity(entity) {
          entity.spatialManager = this;
          this.entities.add(entity);
          this.grid.addEntity(entity);
          if (entity.type === EntityType.PEDESTRIAN) {
            // console.log("Pedestrian registered:", entity);
          }
        }

        unregisterEntity(entity) {
          this.entities.delete(entity);
          this.grid.removeEntity(entity);
        }

        getLaneOccupants(lane) {
          return Array.from(this.entities).filter((entity) => Math.floor(entity.position.x) === lane);
        }

        getEntitiesByType(type) {
          return Array.from(this.entities).filter((entity) => entity.type === type);
        }
      }

      class GridSystem {
        constructor(config) {
          this.config = config;
          this.cellSize = 5; // Size of each grid cell
          this.cells = new Map(); // Map of cell coordinates to sets of entities
        }

        getCellKey(x, y) {
          const cellX = Math.floor(x / this.cellSize);
          const cellY = Math.floor(y / this.cellSize);
          return `${cellX},${cellY}`;
        }

        addEntity(entity) {
          const key = this.getCellKey(entity.position.x, entity.position.y);
          if (!this.cells.has(key)) {
            this.cells.set(key, new Set());
          }
          this.cells.get(key).add(entity);
        }

        removeEntity(entity) {
          const key = this.getCellKey(entity.position.x, entity.position.y);
          const cell = this.cells.get(key);
          if (cell) {
            cell.delete(entity);
            if (cell.size === 0) {
              this.cells.delete(key);
            }
          }
        }

        updateEntityPosition(entity, oldPos, newPos) {
          const oldKey = this.getCellKey(oldPos.x, oldPos.y);
          const newKey = this.getCellKey(newPos.x, newPos.y);

          if (oldKey !== newKey) {
            this.cells.get(oldKey)?.delete(entity);
            if (!this.cells.has(newKey)) {
              this.cells.set(newKey, new Set());
            }
            this.cells.get(newKey).add(entity);
          }
        }

        getNearbyEntities(position, radius) {
          const nearbyEntities = new Set();
          const cellRadius = Math.ceil(radius / this.cellSize);

          const centerCellX = Math.floor(position.x / this.cellSize);
          const centerCellY = Math.floor(position.y / this.cellSize);

          for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
              const key = `${centerCellX + dx},${centerCellY + dy}`;
              const cell = this.cells.get(key);
              if (cell) {
                cell.forEach((entity) => {
                  if (entity.position.distanceTo(position) <= radius) {
                    nearbyEntities.add(entity);
                  }
                });
              }
            }
          }

          return Array.from(nearbyEntities);
        }
      }

      class CollisionManager {
        constructor(spatialManager) {
          this.spatialManager = spatialManager;
          this.config = spatialManager.config;
        }

        checkCollision(hitboxA, hitboxB) {
          // Basic AABB collision detection with hitboxes directly
          return !(
            hitboxA.x + hitboxA.width <= hitboxB.x ||
            hitboxA.x >= hitboxB.x + hitboxB.width ||
            hitboxA.y + hitboxA.height <= hitboxB.y ||
            hitboxA.y >= hitboxB.y + hitboxB.height
          );
        }

        checkPlayerCollision(playerHitbox, entities, isJumping) {
          // First check streetcars and other vehicles
          for (const obstacle of entities.obstacles) {
            // Skip checking streetcar collision only when jumping over tracks
            if (isJumping && obstacle.type === EntityType.STREETCAR) {
              continue;
            }

            if (this.checkCollision(playerHitbox, obstacle.getHitbox())) {
              switch (obstacle.type) {
                case EntityType.STREETCAR:
                  return "STREETCAR";
                case EntityType.STREETCAR_LANE_CAR: // This is the key addition
                  return "TRAFFIC"; // Returns TRAFFIC for cars in streetcar lane
                case EntityType.ONCOMING_CAR:
                  return "TRAFFIC";
                case EntityType.PEDESTRIAN:
                  return "PEDESTRIAN";
                case EntityType.BUILDING:
                  return "SHOP";
                default:
                  console.log("Unknown collision type:", obstacle.type);
                  return "TRAFFIC";
              }
            }
          }

          // Then check parked cars and doors
          for (const car of entities.parkedCars) {
            if (this.checkCollision(playerHitbox, car.getHitbox())) {
              return "PARKEDCAR";
            }
            if (car.behavior.doorHitbox && this.checkCollision(playerHitbox, car.behavior.doorHitbox)) {
              return "DOOR";
            }
          }

          // Finally check track collisions
          const trackPositions = [this.config.LANES.TRACKS + 1, this.config.LANES.TRACKS + 5];
          const playerCenter = playerHitbox.x + playerHitbox.width / 2;
          if (!isJumping && trackPositions.includes(Math.floor(playerCenter))) {
            return "TRACKS";
          }

          return null;
        }

        update() {
          const collisionPairs = this.getCollisionPairs();
          collisionPairs.forEach(([entityA, entityB]) => {
            // Always check for player collisions, regardless of movement state
            if (entityA.type === EntityType.PLAYER || entityB.type === EntityType.PLAYER) {
              const player = entityA.type === EntityType.PLAYER ? entityA : entityB;
              const obstacle = entityA.type === EntityType.PLAYER ? entityB : entityA;

              // Structure entities for collision check
              const entitiesForCollision = {
                obstacles: [obstacle],
                parkedCars: obstacle.type === EntityType.PARKED_CAR ? [obstacle] : [],
              };

              // Check collision and handle if needed
              const collisionType = this.checkPlayerCollision(player.getHitbox(), entitiesForCollision, false);
              if (collisionType) {
                player.behavior.onCollision(obstacle);
              }
            }
          });
        }

        getCollisionPairs() {
          const pairs = [];
          const entities = Array.from(this.spatialManager.entities);

          for (let i = 0; i < entities.length; i++) {
            const entityA = entities[i];
            const nearby = this.spatialManager.grid.getNearbyEntities(entityA.position, Math.max(entityA.width, entityA.height) * 2);

            for (const entityB of nearby) {
              if (entityA !== entityB && this.checkCollision(entityA.getHitbox(), entityB.getHitbox())) {
                pairs.push([entityA, entityB]);
              }
            }
          }

          return pairs;
        }

        validateMovement(entity, newPosition) {
          const tempPosition = entity.position;
          entity.position = newPosition;

          const nearby = this.spatialManager.grid.getNearbyEntities(newPosition, Math.max(entity.width, entity.height) * 2);

          let isValid = true;
          for (const other of nearby) {
            if (other !== entity && !other.behavior.ignoreCollisions && this.checkCollision(entity.getHitbox(), other.getHitbox())) {
              isValid = false;
              break;
            }
          }

          entity.position = tempPosition;
          return isValid;
        }
      }

      class MovementCoordinator {
        constructor(spatialManager) {
          this.spatialManager = spatialManager;
          this.activeMovements = new Map();
        }

        validateMove(entity, newPosition) {
          if (entity.behavior.ignoreCollisions) {
            return true;
          }

          const tempPosition = entity.position;
          entity.position = newPosition;

          const nearby = this.spatialManager.grid.getNearbyEntities(newPosition, Math.max(entity.width, entity.height) * 2);

          let isValid = true;
          for (const other of nearby) {
            if (other !== entity && !other.behavior.ignoreCollisions && this.collisionManager.checkCollision(entity.getHitbox(), other.getHitbox())) {
              isValid = false;
              break;
            }
          }

          entity.position = tempPosition;
          return isValid;
        }

        update() {
          for (const [entity, plan] of this.activeMovements) {
            this.updateMovementPlan(entity, plan);
          }
        }

        updateMovementPlan(entity, plan) {
          if (plan.path.length === 0) {
            this.activeMovements.delete(entity);
            return;
          }

          const nextPosition = plan.path[0];
          if (this.spatialManager.validateMove(entity, nextPosition)) {
            entity.position = nextPosition;
            plan.path.shift();
          } else {
            // Recalculate path if blocked
            this.planMovement(entity, plan.path[plan.path.length - 1]);
          }
        }

        planMovement(entity, destination) {
          // Simple direct path for now - could be expanded to A* pathfinding
          const path = [destination];
          const plan = {
            entity,
            path,
            status: "active",
            priority: this.calculatePriority(entity),
          };

          this.activeMovements.set(entity, plan);
          return plan;
        }

        calculatePriority(entity) {
          // Priority based on entity type and current situation
          const priorities = {
            [EntityType.STREETCAR]: 10,
            [EntityType.PLAYER]: 9,
            [EntityType.STREETCAR_LANE_CAR]: 8,
            [EntityType.ONCOMING_CAR]: 7,
            [EntityType.PARKED_CAR]: 6,
            [EntityType.PEDESTRIAN]: 5,
            [EntityType.BUILDING]: 0,
          };

          return priorities[entity.type] || 0;
        }

        validateLaneChange(entity, newLane) {
          const laneOccupants = this.spatialManager.getLaneOccupants(newLane);
          const safeDistance = this.calculateSafeDistance(entity);

          return laneOccupants.every((occupant) => Math.abs(occupant.position.y - entity.position.y) >= safeDistance);
        }

        calculateSafeDistance(entity) {
          // Safe distances by entity type
          const safeDistances = {
            [EntityType.STREETCAR]: 15,
            [EntityType.STREETCAR_LANE_CAR]: 8,
            [EntityType.ONCOMING_CAR]: 6,
            [EntityType.PARKED_CAR]: 5,
            [EntityType.PEDESTRIAN]: 3,
          };

          return safeDistances[entity.type] || 5;
        }
      }

      class SpawnManager {
        constructor(spatialManager, config) {
          this.spatialManager = spatialManager;
          this.config = config;
          this.initializeSpawnRules();
        }

        initializeSpawnRules() {
          this.spawnRules = new Map([
            [
              EntityType.PEDESTRIAN,
              {
                baseSpacing: 3,
                randomSpacingRange: { min: 1, max: 4 },
                laneRules: {
                  allowedLanes: [this.config.LANES.SIDEWALK],
                  spawnPosition: { x: this.config.LANES.SIDEWALK, y: 0 }, // Changed y from -1 to 0
                  direction: 1,
                },
              },

              EntityType.STREETCAR,
              {
                baseSpacing: 20,
                randomSpacingRange: { min: 5, max: 15 },
                laneRules: {
                  allowedLanes: [this.config.LANES.TRACKS],
                  spawnPosition: { x: this.config.LANES.TRACKS, y: this.config.GAME.HEIGHT + 1 },
                  direction: -1,
                },
              },
            ],
            [
              EntityType.STREETCAR_LANE_CAR,
              {
                baseSpacing: 12,
                randomSpacingRange: { min: 3, max: 10 },
                laneRules: {
                  allowedLanes: [this.config.LANES.TRACKS + 1],
                  spawnPosition: { x: this.config.LANES.TRACKS + 1, y: this.config.GAME.HEIGHT + 1 },
                  direction: -1,
                },
              },
            ],
            [
              EntityType.ONCOMING_CAR,
              {
                baseSpacing: 8,
                randomSpacingRange: { min: 2, max: 8 },
                laneRules: {
                  allowedLanes: [this.config.LANES.ONCOMING],
                  spawnPosition: { x: this.config.LANES.ONCOMING, y: -10 },
                  direction: 1,
                },
              },
            ],
            [
              EntityType.PARKED_CAR,
              {
                baseSpacing: 5,
                randomSpacingRange: { min: 2, max: 6 },
                laneRules: {
                  allowedLanes: [this.config.LANES.PARKED],
                  spawnPosition: { x: this.config.LANES.PARKED, y: -5 },
                  direction: 1,
                },
              },
            ],
            [
              EntityType.PEDESTRIAN,
              {
                baseSpacing: 3,
                randomSpacingRange: { min: 1, max: 4 },
                laneRules: {
                  allowedLanes: [this.config.LANES.SIDEWALK],
                  spawnPosition: { x: this.config.LANES.SIDEWALK, y: -1 },
                  direction: 1,
                },
              },
            ],
          ]);
        }

        canSpawnAt(entityType, position) {
          const rules = this.spawnRules.get(entityType);
          if (!rules) return false;

          // Check if the lane is allowed
          if (!rules.laneRules.allowedLanes.includes(Math.floor(position.x))) {
            return false;
          }
          // Get nearby entities
          const spacing = this.calculateSpacing(entityType);
          const nearbyEntities = Array.from(this.spatialManager.entities).filter((entity) => entity.type === entityType);

          // Check if there's enough space
          return nearbyEntities.every((entity) => {
            const distance = Math.abs(entity.position.y - position.y);
            return distance >= spacing;
          });
        }

        calculateSpacing(entityType) {
          const rules = this.spawnRules.get(entityType);
          if (!rules) return 0;

          const baseSpacing = rules.baseSpacing;

          // Occasionally add random additional spacing
          if (Math.random() < 0.2) {
            const { min, max } = rules.randomSpacingRange;
            return baseSpacing + Math.random() * (max - min) + min;
          }

          return baseSpacing;
        }

        getSpawnConfig(entityType) {
          const rules = this.spawnRules.get(entityType);
          if (!rules) return null;

          return {
            position: new Position(rules.laneRules.spawnPosition.x, rules.laneRules.spawnPosition.y),
            direction: rules.laneRules.direction,
          };
        }

        spawnEntity(entityType) {
          const spawnConfig = this.getSpawnConfig(entityType);
          if (!spawnConfig) return null;

          if (this.canSpawnAt(entityType, spawnConfig.position)) {
            // Create and return the entity based on type
            const EntityClass = this.getEntityClass(entityType);
            if (EntityClass) {
              return new EntityClass(this.config, spawnConfig);
            }
          }

          return null;
        }

        getEntityClass(entityType) {
          const entityClasses = {
            [EntityType.STREETCAR]: Streetcar,
            [EntityType.STREETCAR_LANE_CAR]: StreetcarLaneCar,
            [EntityType.ONCOMING_CAR]: OncomingCar,
            [EntityType.PARKED_CAR]: ParkedCar,
            [EntityType.PEDESTRIAN]: Pedestrian,
            [EntityType.BUILDING]: Building,
          };

          return entityClasses[entityType];
        }
      }

      class EntityBehavior {
        constructor(entity) {
          this.entity = entity;
          this.canMove = true;
        }

        update() {
          // Base update logic
        }

        onCollision(other) {
          // Base collision handling
        }

        canMoveTo(position) {
          return this.entity.spatialManager.validateMove(this.entity, position);
        }
      }

      class StreetcarBehavior extends EntityBehavior {
        constructor(entity) {
          super(entity);
          this.stopSchedule = [];
          this.currentStop = null;
          this.stoppingDistance = 3;
          this.baseSpeed = -1;
          this.ignoreCollisions = true; // Add this flag
        }

        update() {
          // Always move regardless of collision
          this.entity.position.y += this.baseSpeed;
        }

        move() {
          const newPosition = new Position(this.entity.position.x, this.entity.position.y + this.baseSpeed);

          if (this.canMoveTo(newPosition)) {
            this.entity.position = newPosition;
          }
        }

        handleStop() {
          if (this.currentStop.duration > 0) {
            this.currentStop.duration--;
          } else {
            this.currentStop = null;
          }
        }

        scheduleStop(position, duration) {
          this.stopSchedule.push({ position, duration });
        }
      }

      class ParkedCarBehavior extends EntityBehavior {
        constructor(entity) {
          super(entity);
          this.doorState = 0;
          this.doorOpenDuration = 100;
          this.doorTimer = 0;
          this.speed = 1;
          this.doorHitbox = null;

          // Only 30% of cars will open their doors
          this.shouldOpenDoor = Math.random() < 0.3;
          this.doorAnimationActive = false;
          this.lastDoorUpdate = Date.now();
          // Reduce door open delay from 50 to 25 for faster animation
          this.doorOpenDelay = 25;

          // Open doors earlier - between 20-30% of screen height instead of 30-40%
          const targetPercentage = 0.2 + Math.random() * 0.1;
          this.doorOpenY = Math.floor(this.entity.config.GAME.HEIGHT * targetPercentage);
        }

        update() {
          const newPosition = new Position(this.entity.position.x, this.entity.position.y + this.speed);
          this.entity.position = newPosition;

          // Check if door should start opening
          if (
            this.shouldOpenDoor &&
            !this.doorAnimationActive &&
            this.entity.position.y >= this.doorOpenY &&
            this.entity.position.y <= this.doorOpenY + 2
          ) {
            this.doorAnimationActive = true;
            this.updateDoorState();
          }

          // Continue the door animation if it's active
          if (
            this.doorAnimationActive &&
            this.doorState < ENTITIES.PARKED_CAR_STATES.length - 1 &&
            Date.now() - this.lastDoorUpdate > this.doorOpenDelay
          ) {
            this.updateDoorState();
          }

          if (this.doorHitbox) {
            this.doorHitbox.y = this.entity.position.y + 1;
          }
        }

        updateDoorState() {
          this.doorState++;
          this.lastDoorUpdate = Date.now();
          this.entity.art = ENTITIES.PARKED_CAR_STATES[this.doorState];

          const doorWidths = [0, 0.8, 1, 1.5, 1.8];
          const doorWidth = doorWidths[this.doorState];

          // Adjust hitbox height only for the final door state
          const hitboxHeight = this.doorState === ENTITIES.PARKED_CAR_STATES.length - 1 ? 0.8 : 1.8;

          this.doorHitbox = {
            x: this.entity.position.x,
            y: this.entity.position.y + 1,
            width: doorWidth,
            height: hitboxHeight,
          };
        }
      }

      class BuildingBehavior extends EntityBehavior {
        constructor(entity) {
          super(entity);
          this.canMove = true;
          this.speed = 1;
          this.ignoreCollisions = true; // Buildings ignore all collisions
        }

        update() {
          // Always move up at constant speed
          this.entity.position.y += this.speed;

          // Respawn building when it moves off screen
          if (this.entity.position.y >= this.entity.config.GAME.HEIGHT) {
            const buildings = Array.from(this.entity.spatialManager.entities).filter((e) => e.type === EntityType.BUILDING);

            const highestBuilding = buildings.reduce((highest, current) => (current.position.y < highest.position.y ? current : highest));

            this.entity.position.y = highestBuilding.position.y - this.entity.height;
          }
        }
      }

      class VehicleBehavior extends EntityBehavior {
        constructor(entity) {
          super(entity);
          this.baseSpeed = entity.type === EntityType.ONCOMING_CAR ? 2 : -1;
        }

        update() {
          // Always move regardless of collisions
          this.entity.position.y += this.baseSpeed;
        }

        onCollision(other) {
          // Don't stop moving when colliding with player
          if (other.type === EntityType.PLAYER) {
            return;
          }

          // Only adjust position for vehicle-to-vehicle collisions
          if (other.type !== EntityType.PLAYER) {
            if (this.baseSpeed > 0) {
              this.entity.position.y -= 1;
            } else {
              this.entity.position.y += 1;
            }
          }
        }
      }

      class PedestrianBehavior extends EntityBehavior {
        constructor(entity, isGoingUp) {
          super(entity);
          this.isGoingUp = isGoingUp;
          this.baseSpeed = isGoingUp ? -1 : 1;
          this.crossingState = "WALKING";
          this.stepCounter = 0; // Add step counter for slower movement
          this.moveEveryNFrames = 3; // Only move every 3 frames
        }

        update() {
          if (this.crossingState === "WALKING") {
            this.stepCounter++;
            if (this.stepCounter >= this.moveEveryNFrames) {
              const oldX = this.entity.position.x;
              const oldY = this.entity.position.y;

              const newX = Math.round(this.entity.position.x);
              const newY = Math.round(this.entity.position.y + this.baseSpeed);

              // console.log("Pedestrian Position:", {
              //   old: { x: oldX, y: oldY },
              //   new: { x: newX, y: newY },
              //   baseSpeed: this.baseSpeed,
              //   rounded: {
              //     x: Math.round(newX),
              //     y: Math.round(newY),
              //   },
              // });

              const newPosition = new Position(newX, newY);

              if (this.canMoveTo(newPosition)) {
                this.entity.position.x = Math.round(newPosition.x);
                this.entity.position.y = Math.round(newPosition.y);

                // console.log("Position Updated:", {
                //   x: this.entity.position.x,
                //   y: this.entity.position.y,
                // });
              }
              this.stepCounter = 0;
            }
          }
        }
      }

      class PlayerBehavior extends EntityBehavior {
        constructor(entity) {
          super(entity);
          this.canMove = true;
        }

        update() {
          // Player position is managed by the game class
        }

        onCollision(other) {
          // Player collisions are handled by the game class
        }
      }

      class BaseEntity {
        constructor(config, spawnConfig, type) {
          this.config = config;
          this.type = type;
          this.position = new Position(spawnConfig.position.x, spawnConfig.position.y);
          this.width = 0; // Set in child classes
          this.height = 0; // Set in child classes
          this.behavior = null; // Set in child classes
          this.art = null; // Set in child classes
          this.color = null; // Set in child classes
          this.spatialManager = null; // Set when entity is registered
        }

        update() {
          if (this.behavior) {
            this.behavior.update();
          }
        }

        getHitbox() {
          return {
            x: this.position.x,
            y: this.position.y,
            width: this.width,
            height: this.height,
          };
        }
      }

      class Streetcar extends BaseEntity {
        constructor(config, spawnConfig) {
          super(config, spawnConfig, EntityType.STREETCAR);
          this.width = ENTITIES.STREETCAR.width;
          this.height = ENTITIES.STREETCAR.height;
          this.art = ENTITIES.STREETCAR.art;
          this.color = STYLES.TTC;
          this.behavior = new StreetcarBehavior(this);
        }
      }

      class StreetcarLaneCar extends BaseEntity {
        constructor(config, spawnConfig) {
          super(config, spawnConfig, EntityType.STREETCAR_LANE_CAR);
          this.width = ENTITIES.MOVINGCAR.width;
          this.height = ENTITIES.MOVINGCAR.height;
          this.art = ENTITIES.MOVINGCAR.art;
          this.color = `<span style='color: ${this.getRandomVehicleColor()}'>`;
          this.behavior = new VehicleBehavior(this);

          this.getHitbox = () => ({
            x: this.position.x,
            y: this.position.y, // xxxAdjust hitbox down by 1 unit
            width: this.width,
            height: this.height - 1, // Reduce height by 1 unit
          });
        }

        getRandomVehicleColor() {
          return COLOURS.VEHICLES[Math.floor(Math.random() * COLOURS.VEHICLES.length)];
        }
      }

      class OncomingCar extends BaseEntity {
        constructor(config, spawnConfig) {
          super(config, spawnConfig, EntityType.ONCOMING_CAR); // Uses ONCOMING_CAR type
          this.width = ENTITIES.ONCOMINGCAR.width;
          this.height = ENTITIES.ONCOMINGCAR.height;
          this.art = ENTITIES.ONCOMINGCAR.art;
          this.color = `<span style='color: ${this.getRandomVehicleColor()}'>`;
          this.behavior = new VehicleBehavior(this);

          this.getHitbox = () => ({
            x: this.position.x,
            y: this.position.y, // xxxx Adjust hitbox down by 1 unit
            width: this.width,
            height: this.height - 1, // Reduce height by 1 unit
          });
        }

        getRandomVehicleColor() {
          return COLOURS.VEHICLES[Math.floor(Math.random() * COLOURS.VEHICLES.length)];
        }
      }

      class ParkedCar extends BaseEntity {
        constructor(config, spawnConfig) {
          super(config, spawnConfig, EntityType.PARKED_CAR); // Uses PARKED_CAR type
          this.width = 7;
          this.height = 5;
          this.art = ENTITIES.PARKED_CAR_STATES[0];
          this.color = `<span style='color: ${this.getRandomVehicleColor()}'>`;
          this.behavior = new ParkedCarBehavior(this);

          // Adjust hitbox to match visible car
          this.getHitbox = () => ({
            x: this.position.x + 2, // Offset to match visible car
            y: this.position.y,
            width: 4, // Narrower width to match car
            height: this.height,
          });
        }
        getRandomVehicleColor() {
          return COLOURS.VEHICLES[Math.floor(Math.random() * COLOURS.VEHICLES.length)];
        }
      }

      class Pedestrian extends BaseEntity {
        constructor(config, spawnConfig, isGoingUp) {
          super(config, spawnConfig, EntityType.PEDESTRIAN);
          const template = isGoingUp ? ENTITIES.PEDESTRIAN.UP : ENTITIES.PEDESTRIAN.DOWN;
          this.width = template.width;
          this.height = template.height;
          this.art = template.art;
          this.color = STYLES.RESET;
          this.behavior = new PedestrianBehavior(this, isGoingUp);
        }

        getHitbox() {
          const hitbox = {
            x: this.position.x,
            y: this.position.y,
            width: this.width,
            height: this.height,
          };

          // console.log("Pedestrian hitbox properties:", hitbox); // Moved log here after hitbox is created
          return hitbox;
        }
      }

      class Building extends BaseEntity {
        static nextSpawnY = null;

        constructor(config, spawnY = null) {
          const randomShop = TORONTO_SHOPS[Math.floor(Math.random() * TORONTO_SHOPS.length)];
          const height = randomShop.art.length;

          // If spawnY is provided, use it. Otherwise use nextSpawnY or calculate from scratch
          const calculatedY = spawnY ?? (Building.nextSpawnY ? Building.nextSpawnY - height : 0);

          const spawnConfig = {
            position: new Position(config.LANES.SHOPS, calculatedY),
          };

          super(config, spawnConfig, EntityType.BUILDING);
          this.width = randomShop.art[0].length;
          this.height = height;
          this.art = randomShop.art;
          this.color = `<span style='color: ${this.getRandomBuildingColor()}'>`;
          this.behavior = new BuildingBehavior(this);

          // Update the next spawn position
          Building.nextSpawnY = calculatedY;
        }
        getRandomBuildingColor() {
          return COLOURS.BUILDINGS[Math.floor(Math.random() * COLOURS.BUILDINGS.length)];
        }
      }

      class LoserLane {
        constructor() {
          this.spatialManager = new SpatialManager(CONFIG);
          this.initializeState();
          this.setupControls();
          this.setupTouchControls();
          this.grid = this.createGrid();
          this.debug = true; // Add this to toggle hitbox visibility
          this.setupTouchControls();
          this.preventDefaultTouchBehaviors();
        }

        // State Management
        initializeState() {
          this.state = {
            isDead: false,
            score: 0,
            currentLane: CONFIG.LANES.BIKE,
            speed: CONFIG.GAME.INITIAL_SPEED,
            deathAnimation: 0,
            lastTap: 0,
            doubleTapActive: false,
            isJumping: false,
            moveInterval: null,
            movementSpeed: 100,
            isMovingLeft: false,
            isMovingRight: false,
            lastKeyPress: 0,
            isPlaying: false,
            // lastTap: 0,
            // doubleTapActive: false,
            // isJumping: false,
            // moveInterval: null,
            // movementSpeed: 100,
            // isMovingLeft: false,
            // isMovingRight: false,
            // lastKeyPress: 0,
            // isPlaying: false,
            // isPaused: false,
            deathX: 0,
            deathY: 0,
          };

          this.initializeGameWorld();
        }

        initializeGameWorld() {
          // Clear existing entities
          this.spatialManager.entities.clear();

          // Initialize buildings
          this.initializeBuildings();

          // Initialize parked cars
          this.initializeParkedCars();

          // Create player
          this.player = this.createPlayer();
          this.spatialManager.registerEntity(this.player);
        }

        // Control Setup
        setupControls() {
          document.addEventListener("keydown", (e) => {
            if (!this.state.isPlaying && (e.key === " " || e.key === "Spacebar")) {
              this.start();
              return;
            }

            if (this.state.isPlaying) {
              switch (e.key) {
                case "ArrowLeft":
                  this.moveLeft();
                  break;
                case "ArrowRight":
                  this.moveRight();
                  break;
                case "p":
                case "P":
                  this.togglePause();
                  break;
              }
            }
          });

          // Click to play
          document.addEventListener("click", () => {
            if (!this.state.isPlaying) {
              this.start();
            }
          });
        }

        // Modify the setupTouchControls method in LoserLane class
        setupTouchControls() {
          const leftControl = document.getElementById("move-left");
          const rightControl = document.getElementById("move-right");

          if (leftControl && rightControl) {
            const tapState = {
              left: { lastTap: 0, tapCount: 0 },
              right: { lastTap: 0, tapCount: 0 },
            };

            const doubleTapDelay = 400;
            const tapResetDelay = 500;

            const handleTap = (side) => {
              const currentTime = new Date().getTime();
              const state = tapState[side];

              if (currentTime - state.lastTap > tapResetDelay) {
                state.tapCount = 0;
              }

              state.tapCount++;

              if (state.tapCount === 2 && currentTime - state.lastTap <= doubleTapDelay) {
                // Double tap - jump
                if (side === "left") {
                  this.moveLeft(true, false);
                } else {
                  this.moveRight(true, false);
                }
                state.tapCount = 0;
              } else if (state.tapCount === 1) {
                // Single tap - small movement
                if (side === "left") {
                  this.moveLeft(false, true);
                } else {
                  this.moveRight(false, true);
                }
              }

              state.lastTap = currentTime;

              setTimeout(() => {
                state.tapCount = 0;
              }, tapResetDelay);
            };

            // Handle touch events
            leftControl.addEventListener("touchstart", (e) => {
              e.preventDefault();
              handleTap("left");
            });

            rightControl.addEventListener("touchstart", (e) => {
              e.preventDefault();
              handleTap("right");
            });
          }
        }

        preventDefaultTouchBehaviors() {
          // Reference the `game` instance's state to check if it's playing
          document.addEventListener(
            "touchmove",
            (e) => {
              if (game.state.isPlaying && e.touches.length > 1) {
                e.preventDefault();
              }
            },
            { passive: false }
          );

          document.addEventListener(
            "touchend",
            (e) => {
              if (game.state.isPlaying) {
                e.preventDefault();
              }
            },
            { passive: false }
          );

          // Prevent zooming on double tap
          let lastTouchEnd = 0;
          document.addEventListener(
            "touchend",
            (e) => {
              const now = new Date().getTime();
              if (game.state.isPlaying && now - lastTouchEnd <= 300) {
                e.preventDefault();
              }
              lastTouchEnd = now;
            },
            false
          );
        }

        // Modify move functions to support double-tap jumping
        // moveLeft(isDoubleTap = false) {
        //   if (this.state.isDead || this.state.isPaused) return;

        //   const moveAmount = isDoubleTap ? 2 : 1;
        //   const newLane = Math.max(this.state.currentLane - moveAmount, CONFIG.LANES.ONCOMING);
        //   this.state.currentLane = newLane;
        //   this.state.isJumping = isDoubleTap;

        //   // Update player position
        //   this.player.position.x = newLane;

        //   if (isDoubleTap) {
        //     setTimeout(() => {
        //       this.state.isJumping = false;
        //     }, 200);
        //   }
        // }

        // moveRight(isDoubleTap = false) {
        //   if (this.state.isDead || this.state.isPaused) return;

        //   const moveAmount = isDoubleTap ? 2 : 1;
        //   const newLane = Math.min(this.state.currentLane + moveAmount, CONFIG.LANES.SHOPS - 1);
        //   this.state.currentLane = newLane;
        //   this.state.isJumping = isDoubleTap;

        //   // Update player position
        //   this.player.position.x = newLane;

        //   if (isDoubleTap) {
        //     setTimeout(() => {
        //       this.state.isJumping = false;
        //     }, 200);
        //   }
        // }

        moveLeft(isDoubleTap = false, isTouchMove = false) {
          if (this.state.isDead) return;

          const now = Date.now();
          const isDoubleTapJump = !isTouchMove && isDoubleTap && now - this.state.lastTap < CONFIG.GAME.DOUBLE_TAP_TIME;

          // Use smaller movement increment for touch
          const moveAmount = isDoubleTapJump ? 2 : isTouchMove ? 0.5 : 1;
          const newLane = Math.max(this.state.currentLane - moveAmount, CONFIG.LANES.ONCOMING);
          this.state.currentLane = newLane;
          this.state.isJumping = isDoubleTapJump;

          if (isDoubleTapJump) {
            setTimeout(() => {
              this.state.isJumping = false;
            }, 200);
          }

          this.state.lastTap = now;
        }

        moveRight(isDoubleTap = false, isTouchMove = false) {
          if (this.state.isDead) return;

          const now = Date.now();
          const isDoubleTapJump = !isTouchMove && isDoubleTap && now - this.state.lastTap < CONFIG.GAME.DOUBLE_TAP_TIME;

          // Use smaller movement increment for touch
          const moveAmount = isDoubleTapJump ? 2 : isTouchMove ? 0.5 : 1;
          const newLane = Math.min(this.state.currentLane + moveAmount, CONFIG.LANES.SHOPS - 1);
          this.state.currentLane = newLane;
          this.state.isJumping = isDoubleTapJump;

          if (isDoubleTapJump) {
            setTimeout(() => {
              this.state.isJumping = false;
            }, 200);
          }

          this.state.lastTap = now;
        }

        // Game State Management
        start() {
          if (this.state.isPlaying) return;

          const messageBox = document.getElementById("mainMessageBox");
          if (messageBox) {
            messageBox.style.display = "none";
          }

          this.state.isPlaying = true;
          this.gameLoop = setInterval(() => this.update(), this.state.speed);
        }

        togglePause() {
          this.state.isPaused = !this.state.isPaused;

          const messageBox = document.getElementById("mainMessageBox");
          if (messageBox) {
            messageBox.style.display = this.state.isPaused ? "block" : "none";
            messageBox.textContent = this.state.isPaused ? "PAUSED" : "";
          }

          if (this.state.isPaused) {
            clearInterval(this.gameLoop);
          } else {
            this.gameLoop = setInterval(() => this.update(), this.state.speed);
          }
        }

        update() {
          if (this.state.isDead) {
            this.handleDeathAnimation();
            return;
          }

          if (this.state.isPaused) return;

          // Update spatial management systems
          this.spatialManager.update();

          // Update player position
          this.player.position = new Position(this.state.currentLane, this.state.isJumping ? CONFIG.GAME.CYCLIST_Y - 1 : CONFIG.GAME.CYCLIST_Y);

          // Spawn new entities
          this.spawnEntities();

          // Check for collisions with player
          this.checkPlayerCollisions();

          // Update score and speed
          this.updateScore();

          // Render the game
          this.render();
        }

        createPlayer() {
          const playerEntity = new BaseEntity(
            this.config,
            {
              position: new Position(this.state.currentLane, CONFIG.GAME.CYCLIST_Y),
            },
            EntityType.PLAYER
          );

          playerEntity.width = ENTITIES.BIKE.width;
          playerEntity.height = ENTITIES.BIKE.height;
          playerEntity.art = ENTITIES.BIKE.art;
          playerEntity.color = STYLES.BIKE;
          playerEntity.behavior = new PlayerBehavior(playerEntity);

          return playerEntity;
        }

        checkPlayerCollisions() {
          const playerHitbox = {
            x: this.state.currentLane,
            y: this.state.isJumping ? CONFIG.GAME.CYCLIST_Y - 1 : CONFIG.GAME.CYCLIST_Y,
            width: ENTITIES.BIKE.width,
            height: ENTITIES.BIKE.height,
          };

          // Structure the entities object correctly for collision checking
          const entitiesForCollision = {
            obstacles: Array.from(this.spatialManager.entities).filter((e) => e.type !== EntityType.PLAYER && e.type !== EntityType.PARKED_CAR),
            parkedCars: Array.from(this.spatialManager.entities).filter((e) => e.type === EntityType.PARKED_CAR),
          };

          const collision = this.spatialManager.collisionManager.checkPlayerCollision(playerHitbox, entitiesForCollision, this.state.isJumping);

          if (collision) {
            this.die(collision);
          }
        }
        spawnEntities() {
          const spawnChecks = [
            { type: EntityType.STREETCAR, rate: CONFIG.SPAWN_RATES.STREETCAR },
            { type: EntityType.STREETCAR_LANE_CAR, rate: CONFIG.SPAWN_RATES.STREETCAR_LANE_CAR },
            { type: EntityType.ONCOMING_CAR, rate: CONFIG.SPAWN_RATES.ONCOMING_CAR },
            { type: EntityType.PARKED_CAR, rate: CONFIG.SPAWN_RATES.PARKED_CAR },
            { type: EntityType.PEDESTRIAN, rate: CONFIG.SPAWN_RATES.PEDESTRIAN },
          ];

          spawnChecks.forEach(({ type, rate }) => {
            if (Math.random() < rate) {
              const entity = this.spatialManager.spawnManager.spawnEntity(type);
              if (entity) {
                this.spatialManager.registerEntity(entity);
              }
            }
          });
        }

        // Initialization Helpers
        initializeBuildings() {
          let currentY = CONFIG.GAME.HEIGHT;
          while (currentY > -20) {
            const building = new Building(CONFIG, currentY);
            this.spatialManager.registerEntity(building);
            currentY -= building.height;
          }
        }

        initializeParkedCars() {
          let currentY = CONFIG.GAME.HEIGHT;
          while (currentY > -5) {
            const spawnConfig = {
              position: new Position(CONFIG.LANES.PARKED, currentY),
            };

            const car = new ParkedCar(CONFIG, spawnConfig);
            if (this.spatialManager.spawnManager.canSpawnAt(EntityType.PARKED_CAR, car.position)) {
              this.spatialManager.registerEntity(car);
              currentY -= car.height + 1;
            } else {
              currentY -= 1;
            }
          }
        }

        // Rendering
        createGrid() {
          return Array(CONFIG.GAME.HEIGHT)
            .fill()
            .map(() => Array(CONFIG.GAME.WIDTH).fill(" "));
        }

        drawHitbox(hitbox, char, color) {
          if (
            !hitbox ||
            typeof hitbox.x === "undefined" ||
            typeof hitbox.y === "undefined" ||
            typeof hitbox.width === "undefined" ||
            typeof hitbox.height === "undefined"
          ) {
            return;
          }

          const yStart = Math.max(0, Math.floor(hitbox.y));
          const yEnd = Math.min(this.grid.length, Math.ceil(hitbox.y + hitbox.height));
          const xStart = Math.max(0, Math.floor(hitbox.x));
          const xEnd = Math.min(this.grid[0].length, Math.ceil(hitbox.x + hitbox.width));

          // Semi-transparent background with preserved character
          const rgba = color.replace(")", ", 0.3)").replace("rgb", "rgba");

          for (let y = yStart; y < yEnd; y++) {
            for (let x = xStart; x < xEnd; x++) {
              if (y >= 0 && y < CONFIG.GAME.HEIGHT && x >= 0 && x < CONFIG.GAME.WIDTH) {
                // Get the existing content (ASCII art) at this position
                const existingContent = this.grid[y][x];
                let existingChar = " ";

                // Extract the character from existing content if it's wrapped in a span
                if (existingContent.includes("</span>")) {
                  const match = existingContent.match(/>([^<]*)</);
                  if (match && match[1]) {
                    existingChar = match[1];
                  }
                } else {
                  existingChar = existingContent;
                }

                // Create new element with semi-transparent background and preserved character
                this.grid[y][x] = `<span style='background-color: ${rgba}'>${existingChar}</span>`;
              }
            }
          }
        }

        drawHitboxes() {
          this.spatialManager.entities.forEach((entity) => {
            const hitbox = entity.getHitbox();

            if (hitbox) {
              let color;
              switch (entity.type) {
                case EntityType.PEDESTRIAN:
                  color = "rgb(255, 20, 147)"; // Hot pink
                  break;
                case EntityType.STREETCAR:
                  color = "rgb(255, 165, 0)"; // Orange
                  break;
                case EntityType.STREETCAR_LANE_CAR:
                  color = "rgb(0, 191, 255)"; // Deep sky blue
                  break;
                case EntityType.ONCOMING_CAR:
                  color = "rgb(50, 205, 50)"; // Lime green
                  break;
                case EntityType.PARKED_CAR:
                  color = "rgb(138, 43, 226)"; // Blue violet
                  break;
                case EntityType.BUILDING:
                  color = "rgb(255, 215, 0)"; // Gold
                  break;
                default:
                  color = "rgb(45, 45, 45)"; // Default grey
              }
              this.drawHitbox(hitbox, " ", color);
            }

            // Draw door hitbox for parked cars
            if (entity.type === EntityType.PARKED_CAR && entity.behavior.doorHitbox) {
              this.drawHitbox(entity.behavior.doorHitbox, "+", "rgb(255, 0, 0)"); // Keep door hitboxes red
            }
          });

          // Draw player hitbox in cyan
          const playerHitbox = {
            x: this.state.currentLane,
            y: this.state.isJumping ? CONFIG.GAME.CYCLIST_Y - 1 : CONFIG.GAME.CYCLIST_Y,
            width: ENTITIES.BIKE.width,
            height: ENTITIES.BIKE.height,
          };
          this.drawHitbox(playerHitbox, " ", "rgb(0, 255, 255)");
        }

        render() {
          if (this.state.isDead && this.state.deathAnimation >= 10) return;

          this.grid = this.createGrid();

          this.drawRoadFeatures();
          // if (this.debug) this.drawHitboxes();

          this.drawPlayer();

          this.drawEntities();

          const gameScreen = document.getElementById("game-screen");
          if (gameScreen) {
            gameScreen.innerHTML = this.grid.map((row) => row.map((cell) => `<span class="grid-cell">${cell}</span>`).join("")).join("<br />");
          }
        }

        drawRoadFeatures() {
          for (let y = 0; y < CONFIG.GAME.HEIGHT; y++) {
            this.grid[y][CONFIG.LANES.DIVIDER] = STYLES.TRAFFIC + "â•‘" + STYLES.RESET;
            this.grid[y][CONFIG.LANES.DIVIDER + 1] = STYLES.TRAFFIC + "â•‘" + STYLES.RESET;
            this.grid[y][CONFIG.LANES.TRACKS + 1] = STYLES.TRACKS + "â•‘" + STYLES.RESET;
            this.grid[y][CONFIG.LANES.TRACKS + 5] = STYLES.TRACKS + "â•‘" + STYLES.RESET;

            if (y % 3 === 0) {
              this.grid[y][CONFIG.LANES.BIKE - 1] = STYLES.TRAFFIC + " " + STYLES.RESET;
            }

            for (let x = CONFIG.LANES.SIDEWALK; x < CONFIG.LANES.SHOPS; x++) {
              this.grid[y][x] = STYLES.SIDEWALK + " " + STYLES.RESET;
            }
          }
        }

        drawEntities() {
          this.spatialManager.entities.forEach((entity) => {
            if (entity.type !== EntityType.PLAYER) {
              this.drawEntity(entity);
            }
          });
        }

        drawEntity(entity) {
          if (!entity || !entity.art) return;

          if (entity.position.y + entity.height >= 0 && entity.position.y < CONFIG.GAME.HEIGHT) {
            entity.art.forEach((line, i) => {
              if (entity.position.y + i >= 0 && entity.position.y + i < CONFIG.GAME.HEIGHT) {
                line.split("").forEach((char, x) => {
                  if (char !== " " && entity.position.x + x >= 0 && entity.position.x + x < CONFIG.GAME.WIDTH) {
                    // Special handling for pedestrians
                    if (entity.type === EntityType.PEDESTRIAN) {
                      this.grid[Math.floor(entity.position.y + i)][entity.position.x + x] = `<span>${entity.color + char + STYLES.RESET}</span>`;
                    } else {
                      this.grid[Math.floor(entity.position.y + i)][entity.position.x + x] = entity.color + char + STYLES.RESET;
                    }
                  }
                });
              }
            });
          }
        }

        drawPlayer() {
          if (this.state.isDead && this.state.deathAnimation < 10) {
            ENTITIES.EXPLOSION.art.forEach((line, i) => {
              line.split("").forEach((char, x) => {
                if (this.state.deathY + i < CONFIG.GAME.HEIGHT) {
                  this.grid[this.state.deathY + i][this.state.deathX + x] = STYLES.TRAFFIC + char + STYLES.RESET;
                }
              });
            });
          } else if (!this.state.isDead) {
            const bikeY = this.state.isJumping ? CONFIG.GAME.CYCLIST_Y - 1 : CONFIG.GAME.CYCLIST_Y;
            ENTITIES.BIKE.art.forEach((line, i) => {
              line.split("").forEach((char, x) => {
                if (char !== " ") {
                  // Wrap each character with a light yellow background
                  this.grid[bikeY + i][this.state.currentLane + x] = `<span class="bike-highlight">${char}</span>`;
                }
              });
            });
          }
        }
        // Death Handling
        die(reason) {
          this.state.isDead = true;
          this.state.deathX = this.state.currentLane;
          this.state.deathY = CONFIG.GAME.CYCLIST_Y;

          this.flashScreen();
          this.showDeathMessage(reason);

          setTimeout(() => {
            const messageEl = document.getElementById("mainMessageBox");
            if (messageEl) {
              messageEl.classList.remove("show-message");
            }
            this.restart();
          }, 1000);
        }

        flashScreen() {
          const gameScreen = document.getElementById("game-screen");
          if (!gameScreen) return;

          const colors = ["#FF0000", "#000000", "#222"];
          let delay = 0;

          colors.forEach((color) => {
            setTimeout(() => {
              gameScreen.style.backgroundColor = color;
            }, delay);
            delay += 100;
          });
        }

        showDeathMessage(reason) {
          const messageEl = document.getElementById("mainMessageBox");
          if (!messageEl) return;

          const randomMessage = this.getRandomDeathMessage(reason);
          const randomFace = cuteDeathFaces[Math.floor(Math.random() * cuteDeathFaces.length)];

          messageEl.innerHTML = `
            <span class="message-reason">${randomMessage.reason}</span><br /><br />
            ${randomMessage.funny}<br /><br />
            <span class="cute-face">${randomFace}</span>
          `;
          messageEl.style.display = "block";
        }

        getRandomDeathMessage(type) {
          const messages = MESSAGES.DEATH[type];
          if (!messages?.length) {
            return {
              reason: "X X!",
              funny: "Sometimes things just happen",
            };
          }
          return messages[Math.floor(Math.random() * messages.length)];
        }

        // Game Reset
        restart() {
          Building.nextSpawnY = null;
          this.spatialManager = new SpatialManager(CONFIG);
          this.initializeState();
          this.start();

          const messageBox = document.getElementById("mainMessageBox");
          if (messageBox) {
            messageBox.textContent = "CLICK HERE/SPACEBAR to play ";
          }
        }

        handleDeathAnimation() {
          this.state.deathAnimation++;
          if (this.state.deathAnimation > 10) {
            clearInterval(this.gameLoop);
            this.state.isPlaying = false;
            return;
          }
          this.render();
        }

        updateScore() {
          this.state.score++;

          const scoreElement = document.getElementById("time-alive");
          if (scoreElement) {
            scoreElement.textContent = `STAY ALIVE! ${this.state.score}`;
          }

          this.state.speed = Math.max(this.state.speed * CONFIG.GAME.SPEED_DECREASE_RATE, CONFIG.GAME.MIN_SPEED);

          clearInterval(this.gameLoop);
          this.gameLoop = setInterval(() => this.update(), this.state.speed);
        }

        // Cleanup
        cleanup() {
          clearInterval(this.gameLoop);
          // Add any additional cleanup needed
        }
      }

      /////////////////////////////////////////
      ///////////SETTINGS WINDOW /////////////
      ////////////////////////////////////////

      // Toggle settings window visibility with "D" key
      document.addEventListener("keydown", (e) => {
        if (e.key.toLowerCase() === "d") {
          const settingsWindow = document.getElementById("settings-window");
          settingsWindow.style.display = settingsWindow.style.display === "none" ? "block" : "none";
        }
      });

      // Update configuration values and display value on input change
      document.getElementById("pedestrian-speed").addEventListener("input", (e) => {
        CONFIG.PEDESTRIAN.SPEED = parseFloat(e.target.value);
        document.getElementById("pedestrian-speed-value").textContent = e.target.value;
      });

      document.getElementById("streetcar-spawn-rate").addEventListener("input", (e) => {
        CONFIG.SPAWN_RATES.STREETCAR = parseFloat(e.target.value);
        document.getElementById("streetcar-spawn-rate-value").textContent = e.target.value;
      });

      document.getElementById("oncoming-car-spawn-rate").addEventListener("input", (e) => {
        CONFIG.SPAWN_RATES.ONCOMING_CAR = parseFloat(e.target.value);
        document.getElementById("oncoming-car-spawn-rate-value").textContent = e.target.value;
      });

      document.getElementById("parked-car-spawn-rate").addEventListener("input", (e) => {
        CONFIG.SPAWN_RATES.PARKED_CAR = parseFloat(e.target.value);
        document.getElementById("parked-car-spawn-rate-value").textContent = e.target.value;
      });

      document.getElementById("streetcar-lane-car-spawn-rate").addEventListener("input", (e) => {
        CONFIG.SPAWN_RATES.STREETCAR_LANE_CAR = parseFloat(e.target.value);
        document.getElementById("streetcar-lane-car-spawn-rate-value").textContent = e.target.value;
      });

      document.getElementById("pedestrian-spawn-rate").addEventListener("input", (e) => {
        CONFIG.SPAWN_RATES.PEDESTRIAN = parseFloat(e.target.value);
        document.getElementById("pedestrian-spawn-rate-value").textContent = e.target.value;
      });

      document.getElementById("initial-speed").addEventListener("input", (e) => {
        CONFIG.GAME.INITIAL_SPEED = parseInt(e.target.value);
        document.getElementById("initial-speed-value").textContent = e.target.value;
      });

      document.getElementById("min-speed").addEventListener("input", (e) => {
        CONFIG.GAME.MIN_SPEED = parseInt(e.target.value);
        document.getElementById("min-speed-value").textContent = e.target.value;
      });

      document.getElementById("speed-decrease-rate").addEventListener("input", (e) => {
        CONFIG.GAME.SPEED_DECREASE_RATE = parseFloat(e.target.value);
        document.getElementById("speed-decrease-rate-value").textContent = e.target.value;
      });

      // Vehicle Gap Controls
      document.getElementById("streetcar-gap").addEventListener("input", (e) => {
        CONFIG.SAFE_DISTANCE.STREETCAR = parseInt(e.target.value);
        document.getElementById("streetcar-gap-value").textContent = e.target.value;
      });

      document.getElementById("lane-car-gap").addEventListener("input", (e) => {
        CONFIG.SAFE_DISTANCE.STREETCAR_LANE_CAR = parseInt(e.target.value);
        document.getElementById("lane-car-gap-value").textContent = e.target.value;
      });

      document.getElementById("oncoming-car-gap").addEventListener("input", (e) => {
        CONFIG.SAFE_DISTANCE.ONCOMING_CAR = parseInt(e.target.value);
        document.getElementById("oncoming-car-gap-value").textContent = e.target.value;
      });

      // Lane Width and Cyclist Speed Controls
      document.getElementById("lane-width").addEventListener("input", (e) => {
        CONFIG.GAME.WIDTH = parseInt(e.target.value);
        document.getElementById("lane-width-value").textContent = e.target.value;
      });

      document.getElementById("cyclist-speed").addEventListener("input", (e) => {
        game.state.movementSpeed = parseInt(e.target.value);
        document.getElementById("cyclist-speed-value").textContent = e.target.value;
      });
    </script>
    <script src="shops.js"></script>
    <script src="cuteDeathFaces.js"></script>
    <script src="colours.js"></script>
    <script src="assets.js"></script>
    <script src="messages.js"></script>
    <script src="config.js"></script>
    <script>
      let game;
      document.addEventListener("DOMContentLoaded", () => {
        game = new LoserLane();
      });
    </script>
  </body>
</html>
