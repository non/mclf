<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Loser Lane</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div id="game-container">
      <!-- Settings Window -->
      <div id="settings-window">
        <h3>Game Settings</h3>

        <!-- Pedestrian Speed -->
        <label for="pedestrian-speed"
          >Pedestrian Speed
          <span id="pedestrian-speed-value" class="value-display">0.5</span>
        </label>
        <input id="pedestrian-speed" type="range" min="0.1" max="3" step="0.1" value="0.5" />

        <!-- Spawn Rates -->
        <label for="streetcar-spawn-rate"
          >Streetcar Spawn Rate
          <span id="streetcar-spawn-rate-value" class="value-display">0.03</span>
        </label>
        <input id="streetcar-spawn-rate" type="range" min="0.01" max="1" step="0.01" value="0.03" />

        <label for="oncoming-car-spawn-rate"
          >Oncoming Car Spawn Rate
          <span id="oncoming-car-spawn-rate-value" class="value-display">0.15</span>
        </label>
        <input id="oncoming-car-spawn-rate" type="range" min="0.01" max="1" step="0.01" value="0.15" />

        <label for="parked-car-spawn-rate"
          >Parked Car Spawn Rate
          <span id="parked-car-spawn-rate-value" class="value-display">0.15</span>
        </label>
        <input id="parked-car-spawn-rate" type="range" min="0.01" max="1" step="0.01" value="0.15" />

        <label for="streetcar-lane-car-spawn-rate"
          >Streetcar Lane Car Spawn Rate
          <span id="streetcar-lane-car-spawn-rate-value" class="value-display">0.3</span>
        </label>
        <input id="streetcar-lane-car-spawn-rate" type="range" min="0.01" max="1" step="0.01" value="0.3" />

        <label for="pedestrian-spawn-rate"
          >Pedestrian Spawn Rate
          <span id="pedestrian-spawn-rate-value" class="value-display">0.05</span>
        </label>
        <input id="pedestrian-spawn-rate" type="range" min="0.01" max="1" step="0.01" value="0.05" />

        <!-- Game Speed Controls -->
        <label for="initial-speed"
          >Initial Game Speed
          <span id="initial-speed-value" class="value-display">500</span>
        </label>
        <input id="initial-speed" type="range" min="100" max="1000" step="10" value="500" />

        <label for="min-speed"
          >Minimum Game Speed
          <span id="min-speed-value" class="value-display">300</span>
        </label>
        <input id="min-speed" type="range" min="100" max="1000" step="10" value="300" />

        <label for="speed-decrease-rate"
          >Speed Decrease Rate
          <span id="speed-decrease-rate-value" class="value-display">0.995</span>
        </label>
        <input id="speed-decrease-rate" type="range" min="0.9" max="1" step="0.001" value="0.995" />

        <!-- Gaps Between Vehicles -->
        <label for="streetcar-gap"
          >Streetcar Gap
          <span id="streetcar-gap-value" class="value-display">20</span>
        </label>
        <input id="streetcar-gap" type="range" min="10" max="50" step="1" value="20" />

        <label for="lane-car-gap"
          >Streetcar Lane Car Gap
          <span id="lane-car-gap-value" class="value-display">12</span>
        </label>
        <input id="lane-car-gap" type="range" min="10" max="50" step="1" value="12" />

        <label for="oncoming-car-gap"
          >Oncoming Car Gap
          <span id="oncoming-car-gap-value" class="value-display">8</span>
        </label>
        <input id="oncoming-car-gap" type="range" min="5" max="30" step="1" value="8" />

        <!-- Lane Widths and Cyclist Speed -->
        <label for="lane-width"
          >Lane Width
          <span id="lane-width-value" class="value-display">45</span>
        </label>
        <input id="lane-width" type="range" min="20" max="60" step="1" value="45" />

        <label for="cyclist-speed"
          >Cyclist Speed
          <span id="cyclist-speed-value" class="value-display">100</span>
        </label>
        <input id="cyclist-speed" type="range" min="50" max="200" step="5" value="100" />
      </div>

      <div id="game-screen"></div>
      <div id="mainMessageBox">
        <!-- <span id="gameTitle">L O S E R ~ L A N E</span><br /><br /> -->

        CLICK or SPACEBAR to start<br /><br />
        LEFT/RIGHT arrow keys or CLICK sides to move<br /><br />
        DOUBLE-TAP to jump tracks!
      </div>
      <br />
      <div id="controls">
        <div class="control-area" id="move-left"></div>
        <div class="control-area" id="move-right"></div>
      </div>
      <div class="info-box">
        <!-- <div id="title">L O S E R ~ L A N E</div>
        <div id="time-alive">STAY ALIVE 0</div> -->

        <div id="title-container">
          <div class="bike-art-left">
            __o <br />
            _ \<_ <br />
            (_)/(_)
          </div>

          <div class="title-text">
            <div id="title">L O S E R ~ L A N E</div>
            <div id="time-alive">STAY ALIVE? 0</div>
          </div>

          <div class="bike-art-right">
            o__ <br />
            _ >/ _ <br />
            (_) \(_)
          </div>
        </div>
      </div>
    </div>

    <script>
      // Constants and Configuration

      const CONFIG = {
        GAME: {
          WIDTH: 45,
          HEIGHT: Math.floor(window.innerHeight / 20),
          INITIAL_SPEED: 500, // Changed from 20 to match settings window
          MIN_SPEED: 300,
          SPEED_DECREASE_RATE: 0.995,
          CYCLIST_Y: Math.floor(window.innerHeight / 40),
          DOUBLE_TAP_TIME: 350,
        },
        SPAWN_RATES: {
          STREETCAR: 0.03,
          STREETCAR_LANE_CAR: 0.3,
          ONCOMING_CAR: 0.15,
          PARKED_CAR: 0.15,
          DOOR_OPENING: 0.1,
          PEDESTRIAN: 0.05,
          BUILDING: 0.05,
        },
        SAFE_DISTANCE: {
          // Added missing configuration section
          STREETCAR: 15,
          STREETCAR_LANE_CAR: 8,
          ONCOMING_CAR: 6,
          PARKED: 5,
          PEDESTRIAN: 3,
          BUILDING: 0,
        },
        PEDESTRIAN: {
          SPEED: 0.5,
        },
        LANES: {
          ONCOMING: 2,
          DIVIDER: 8,
          TRACKS: 12,
          BIKE: 19,
          BIKE_RIGHT: 20,
          PARKED: 22,
          SIDEWALK: 30,
          SHOPS: 34,
        },
      };

      class BaseObstacle {
        constructor(x, y, template, config) {
          this.type = template.type;
          this.art = template.art;
          this.x = x;
          this.y = y;
          this.width = template.width;
          this.height = template.height;
          this.speed = template.speed || 0;
          this.color = template.color || STYLES.RESET;
          this.config = config;

          this.hitbox = {
            x: x,
            y: y,
            width: template.width,
            height: template.height,
          };
        }

        update() {
          const updatedY = this.y + this.speed;
          this.y = updatedY;
          this.hitbox.y = updatedY;
          return this.isOnScreen();
        }

        isOnScreen() {
          return this.speed > 0 ? this.y < this.config.GAME.HEIGHT + 2 : this.y + this.height > -2;
        }
      }

      class Streetcar extends BaseObstacle {
        constructor(config, collisionManager) {
          const spawnConfig = collisionManager.getSpawnConfig("streetcar");
          super(
            spawnConfig.x,
            spawnConfig.y,
            {
              type: "STREETCAR",
              art: ENTITIES.STREETCAR.art,
              width: ENTITIES.STREETCAR.width,
              height: ENTITIES.STREETCAR.height,
              speed: spawnConfig.speed,
              color: STYLES.TTC,
            },
            config
          );
        }

        update() {
          const updatedY = this.y - 1;
          this.y = updatedY;
          this.hitbox.y = updatedY;
          return this.y + this.height > -2;
        }
      }

      class StreetcarLaneCar extends BaseObstacle {
        constructor(config, collisionManager) {
          const spawnConfig = collisionManager.getSpawnConfig("streetcarLaneCar");
          const vehicleColor = COLOURS.VEHICLES[Math.floor(Math.random() * COLOURS.VEHICLES.length)];

          super(
            spawnConfig.x,
            spawnConfig.y,
            {
              type: "STREETCAR_LANE_CAR",
              art: ENTITIES.MOVINGCAR.art,
              width: ENTITIES.MOVINGCAR.width,
              height: ENTITIES.MOVINGCAR.height,
              speed: spawnConfig.speed,
              color: `<span style='color: ${vehicleColor}'>`,
            },
            config
          );
        }
      }

      class OncomingCar extends BaseObstacle {
        constructor(config, collisionManager) {
          const spawnConfig = collisionManager.getSpawnConfig("oncoming");
          const vehicleColor = COLOURS.VEHICLES[Math.floor(Math.random() * COLOURS.VEHICLES.length)];

          super(
            spawnConfig.x,
            spawnConfig.y,
            {
              type: "CAR",
              art: ENTITIES.ONCOMINGCAR.art,
              width: ENTITIES.ONCOMINGCAR.width,
              height: ENTITIES.ONCOMINGCAR.height,
              speed: spawnConfig.speed,
              color: `<span style='color: ${vehicleColor}'>`,
            },
            config
          );
          this.collisionManager = collisionManager;
        }
      }

      class Building extends BaseObstacle {
  static nextSpawnY = null;

  constructor(config, spawnY = null) {
    const randomShop = TORONTO_SHOPS[Math.floor(Math.random() * TORONTO_SHOPS.length)];
    const buildingHeight = randomShop.art.length;

    spawnY = spawnY ?? (Building.nextSpawnY ? Building.nextSpawnY - buildingHeight : 0);

    super(
      config.LANES.SHOPS,
      spawnY,
      {
        type: "BUILDING",
        art: randomShop.art,
        width: randomShop.art[0].length,
        height: buildingHeight,
        speed: 1,
        color: `<span style='color: ${COLOURS.BUILDINGS[Math.floor(Math.random() * COLOURS.BUILDINGS.length)]}'>`,
      },
      config
    );

    Building.nextSpawnY = this.y;
  }
}


      class ParkedCar extends BaseObstacle {
        constructor(config, collisionManager) {
          const spawnConfig = collisionManager.getSpawnConfig("parked");
          const vehicleColor = COLOURS.VEHICLES[Math.floor(Math.random() * COLOURS.VEHICLES.length)];
          const state0Art = ENTITIES.PARKED_CAR_STATES[0];

          super(
            config.LANES.PARKED,
            spawnConfig.y,
            {
              type: "PARKED",
              art: state0Art,
              width: 7,
              height: 5,
              speed: 1,
              color: `<span style='color: ${vehicleColor}'>`,
            },
            config
          );

          this.hitbox = {
            x: config.LANES.PARKED + 2,
            y: spawnConfig.y,
            width: 4,
            height: 5,
          };

          this.doorHitbox = null;
          this.doorState = 0;
          this.shouldOpenDoor = Math.random() < 0.2;
          this.doorAnimationActive = false;
          this.lastDoorUpdate = Date.now();
          this.doorOpenDelay = 100;

          if (this.shouldOpenDoor) {
            const minY = Math.floor(this.config.GAME.HEIGHT * 0.25);
            const maxY = Math.floor(this.config.GAME.HEIGHT * 0.75);
            this.doorOpenY = Math.floor(Math.random() * (maxY - minY)) + minY;
          }
        }

        update() {
          const updatedY = this.y + this.speed;
          this.y = updatedY;
          this.hitbox.y = updatedY;

          if (this.doorHitbox) {
            this.doorHitbox.y = updatedY + 1;
          }

          if (this.shouldOpenDoor && !this.doorAnimationActive && this.y >= this.doorOpenY && this.y <= this.doorOpenY + 2) {
            this.doorAnimationActive = true;
            this.updateDoorState();
          }

          if (
            this.doorAnimationActive &&
            this.doorState < ENTITIES.PARKED_CAR_STATES.length - 1 &&
            Date.now() - this.lastDoorUpdate > this.doorOpenDelay
          ) {
            this.updateDoorState();
          }

          return this.y < this.config.GAME.HEIGHT + 2;
        }

        updateDoorState() {
          this.doorState++;
          this.lastDoorUpdate = Date.now();
          this.art = ENTITIES.PARKED_CAR_STATES[this.doorState];

          const doorWidths = [0, 0.8, 1, 1.5, 1.8];
          const doorWidth = doorWidths[this.doorState];

          this.doorHitbox = {
            x: this.hitbox.x - doorWidth,
            y: this.y + 1,
            width: doorWidth,
            height: 1.8,
          };
        }
      }

      class Pedestrian extends BaseObstacle {
        constructor(config, isGoingUp) {
          const template = isGoingUp ? ENTITIES.PEDESTRIAN.UP : ENTITIES.PEDESTRIAN.DOWN;
          super(
            config.LANES.SIDEWALK,
            isGoingUp ? config.GAME.HEIGHT : -1,
            {
              type: "PEDESTRIAN",
              art: template.art,
              width: template.width,
              height: template.height,
              speed: config.PEDESTRIAN.SPEED * (isGoingUp ? -1 : 1),
            },
            config
          );
        }

        update() {
          const updatedY = this.y + this.speed;
          this.y = updatedY;
          this.hitbox.y = updatedY;
          return this.speed > 0 ? this.y < this.config.GAME.HEIGHT + 2 : this.y + this.height > -2;
        }
      }

      class ObstacleManager {
        constructor(config, collisionManager) {
          this.config = config;
          this.collisionManager = collisionManager;
          this.obstacles = [];
          this.parkedCars = [];
          this.initializeBuildings();
          this.initializeParkedCars();
        }

        update() {
          this.obstacles = this.obstacles.filter((obstacle) => {
            const keepObstacle = obstacle.update();
            if (!keepObstacle) {
              this.collisionManager.removeEntity(obstacle);
            }
            return keepObstacle;
          });

          this.parkedCars = this.parkedCars.filter((car) => {
            const keepCar = car.update();
            if (!keepCar) {
              this.collisionManager.removeEntity(car);
            }
            return keepCar;
          });
        }

        initializeParkedCars() {
          let currentY = this.config.GAME.HEIGHT;

          while (currentY > -5) {
            const car = new ParkedCar(this.config, this.collisionManager);
            car.y = currentY;

            if (this.collisionManager.canSpawn("PARKED", currentY)) {
              this.collisionManager.addEntity(car);
              this.parkedCars.push(car);
              currentY -= car.height + 1;
            } else {
              currentY -= 1;
            }
          }
        }

        initializeBuildings() {
          let currentY = this.config.GAME.HEIGHT;

          while (currentY > -20) {
            const building = new Building(this.config, currentY);
            this.collisionManager.addEntity(building);
            this.obstacles.push(building);
            currentY -= building.height;
          }
        }

        spawn() {
          // Streetcar spawn
          if (Math.random() < this.config.SPAWN_RATES.STREETCAR) {
            const spawnConfig = this.collisionManager.getSpawnConfig("streetcar");
            if (this.collisionManager.canSpawn("STREETCAR", spawnConfig.y)) {
              const streetcar = new Streetcar(this.config, this.collisionManager);
              this.collisionManager.addEntity(streetcar);
              this.obstacles.push(streetcar);
            }
          }

          // Streetcar lane car spawn
          if (Math.random() < this.config.SPAWN_RATES.STREETCAR_LANE_CAR) {
            const spawnConfig = this.collisionManager.getSpawnConfig("streetcarLaneCar");
            if (this.collisionManager.canSpawn("STREETCAR_LANE_CAR", spawnConfig.y)) {
              const car = new StreetcarLaneCar(this.config, this.collisionManager);
              this.collisionManager.addEntity(car);
              this.obstacles.push(car);
            }
          }

          // Oncoming car spawn
          if (Math.random() < this.config.SPAWN_RATES.ONCOMING_CAR) {
            const spawnConfig = this.collisionManager.getSpawnConfig("oncoming");
            if (this.collisionManager.canSpawn("CAR", spawnConfig.y)) {
              const car = new OncomingCar(this.config, this.collisionManager);
              this.collisionManager.addEntity(car);
              this.obstacles.push(car);
            }
          }

          // Parked car spawn
          if (Math.random() < this.config.SPAWN_RATES.PARKED_CAR) {
            const spawnConfig = this.collisionManager.getSpawnConfig("parked");
            if (this.collisionManager.canSpawn("PARKED", spawnConfig.y)) {
              const car = new ParkedCar(this.config, this.collisionManager);
              this.collisionManager.addEntity(car);
              this.parkedCars.push(car);
            }
          }

          // Building spawn
          const buildings = this.obstacles.filter((obs) => obs.type === "BUILDING");
          if (buildings.length > 0) {
            const highestBuilding = buildings.reduce((highest, current) => (current.y < highest.y ? current : highest));

            if (highestBuilding.y > 0) {
              const newBuilding = new Building(this.config, highestBuilding.y - highestBuilding.height);
              this.collisionManager.addEntity(newBuilding);
              this.obstacles.push(newBuilding);
            }
          }

          // Pedestrian spawn
          if (Math.random() < this.config.SPAWN_RATES.PEDESTRIAN) {
            const isGoingUp = Math.random() > 0.5;
            const pedestrian = new Pedestrian(this.config, isGoingUp);
            this.collisionManager.addEntity(pedestrian);
            this.obstacles.push(pedestrian);
          }
        }

        getAllObjects() {
          return [...this.obstacles, ...this.parkedCars];
        }
      }

      class CollisionManager {
        constructor(config) {
          this.config = config;
          this.entities = [];
          this.minSpacing = config.SAFE_DISTANCE; // Use configuration values
        }

        addEntity(entity) {
          this.entities.push(entity);
        }

        removeEntity(entity) {
          const index = this.entities.indexOf(entity);
          if (index > -1) {
            this.entities.splice(index, 1);
          }
        }

        update() {
          this.entities = this.entities.filter((entity) => entity.y + entity.height > -5 && entity.y < this.config.GAME.HEIGHT + 5);
        }

        getSpawnConfig(type) {
          const configs = {
            streetcar: {
              x: this.config.LANES.TRACKS,
              y: this.config.GAME.HEIGHT + 1,
              speed: -1,
            },
            streetcarLaneCar: {
              x: this.config.LANES.TRACKS + 1,
              y: this.config.GAME.HEIGHT + 1,
              speed: -1,
            },
            oncoming: {
              x: this.config.LANES.ONCOMING,
              y: -10,
              speed: 2,
            },
            parked: {
              x: this.config.LANES.PARKED,
              y: -5,
              speed: 1,
            },
          };
          return configs[type];
        }

        canSpawn(type, y) {
          const minSpace = this.minSpacing[type.toUpperCase()] || 0;

          // Only check entities of the same type that are nearby
          const nearbyEntities = this.entities.filter((entity) => entity.type === type && Math.abs(entity.y - y) < (entity.height + minSpace) * 2);

          return nearbyEntities.every((entity) => Math.abs(entity.y - y) >= entity.height + minSpace);
        }

        checkPlayerCollision(playerHitbox, entities, isJumping) {
          // Check parked cars first (including doors)
          for (const car of entities.parkedCars) {
            if (this.checkOverlap(playerHitbox, car.hitbox)) {
              return "PARKEDCAR";
            }
            if (car.doorHitbox && this.checkOverlap(playerHitbox, car.doorHitbox)) {
              return "DOOR";
            }
          }

          // Check all other obstacles
          for (const obstacle of entities.obstacles) {
            // Skip streetcar collisions when jumping
            if (isJumping && obstacle.type === "STREETCAR") continue;

            if (this.checkOverlap(playerHitbox, obstacle.hitbox)) {
              return obstacle.type;
            }
          }

          // Check track collisions
          if (this.checkTrackCollision(playerHitbox)) {
            return "TRACKS";
          }

          // Check shop collisions
          if (this.checkShopCollision(playerHitbox)) {
            return "SHOP";
          }

          return null;
        }

        checkTrackCollision(playerHitbox) {
          const trackPositions = [this.config.LANES.TRACKS + 1, this.config.LANES.TRACKS + 5];
          const playerCenter = playerHitbox.x + playerHitbox.width / 2;
          return trackPositions.includes(Math.floor(playerCenter));
        }

        checkShopCollision(playerHitbox) {
          return this.checkOverlap(playerHitbox, {
            x: this.config.LANES.SHOPS,
            y: 0,
            width: this.config.GAME.WIDTH - this.config.LANES.SHOPS,
            height: this.config.GAME.HEIGHT,
          });
        }

        checkOverlap(boxA, boxB) {
          return !(
            boxA.x + boxA.width <= boxB.x ||
            boxA.x >= boxB.x + boxB.width ||
            boxA.y + boxA.height <= boxB.y ||
            boxA.y >= boxB.y + boxB.height
          );
        }
      }
      // Main Game Class
      class LoserLane {
  constructor() {
    this.collisionManager = new CollisionManager(CONFIG);
    this.obstacleManager = new ObstacleManager(CONFIG, this.collisionManager);
    this.initializeState();
    this.setupControls();
    this.setupTouchControls();
    this.grid = this.createGrid();
  }

  // State Management
  initializeState() {
    this.state = {
      isDead: false,
      score: 0,
      currentLane: CONFIG.LANES.BIKE,
      speed: CONFIG.GAME.INITIAL_SPEED,
      deathAnimation: 0,
      lastTap: 0,
      doubleTapActive: false,
      isJumping: false,
      moveInterval: null,
      movementSpeed: 100,
      isMovingLeft: false,
      isMovingRight: false,
      lastKeyPress: 0,
      isPlaying: false,
      isPaused: false
    };
    this.entities = {
      obstacles: [],
      parkedCars: []
    };
  }

  // Control Setup
  setupControls() {
    document.addEventListener("keydown", (e) => {
      if (!this.state.isPlaying) {
        this.start();
        return;
      }

      switch (e.key) {
        case "ArrowLeft":
          this.moveLeft();
          break;
        case "ArrowRight":
          this.moveRight();
          break;
        case "p":
        case "P":
          this.togglePause();
          break;
      }
    });
  }

  setupTouchControls() {
    const leftControl = document.getElementById('move-left');
    const rightControl = document.getElementById('move-right');
    
    if (leftControl && rightControl) {
      leftControl.addEventListener('click', () => {
        const now = Date.now();
        const isDoubleTap = now - this.state.lastTap < CONFIG.GAME.DOUBLE_TAP_TIME;
        this.state.lastTap = now;
        this.moveLeft(isDoubleTap);
      });

      rightControl.addEventListener('click', () => {
        const now = Date.now();
        const isDoubleTap = now - this.state.lastTap < CONFIG.GAME.DOUBLE_TAP_TIME;
        this.state.lastTap = now;
        this.moveRight(isDoubleTap);
      });
    }
  }

  // Movement Controls
  moveLeft(isDoubleTap = false) {
    if (this.state.isDead || this.state.isPaused) return;

    const moveAmount = isDoubleTap ? 2 : 1;
    const newLane = Math.max(this.state.currentLane - moveAmount, CONFIG.LANES.ONCOMING);
    this.state.currentLane = newLane;
    this.state.isJumping = isDoubleTap;

    if (isDoubleTap) {
      setTimeout(() => {
        this.state.isJumping = false;
      }, 200);
    }
  }

  moveRight(isDoubleTap = false) {
    if (this.state.isDead || this.state.isPaused) return;

    const moveAmount = isDoubleTap ? 2 : 1;
    const newLane = Math.min(this.state.currentLane + moveAmount, CONFIG.LANES.SHOPS - 1);
    this.state.currentLane = newLane;
    this.state.isJumping = isDoubleTap;

    if (isDoubleTap) {
      setTimeout(() => {
        this.state.isJumping = false;
      }, 200);
    }
  }

  // Game State Management
  start() {
    if (this.state.isPlaying) return;

    const messageBox = document.getElementById("mainMessageBox");
    if (messageBox) {
      messageBox.style.display = "none";
    }
    
    this.state.isPlaying = true;
    this.gameLoop = setInterval(() => this.update(), this.state.speed);
  }

  togglePause() {
    this.state.isPaused = !this.state.isPaused;
    
    const messageBox = document.getElementById("mainMessageBox");
    if (messageBox) {
      messageBox.style.display = this.state.isPaused ? "block" : "none";
      messageBox.textContent = this.state.isPaused ? "PAUSED" : "";
    }

    if (this.state.isPaused) {
      clearInterval(this.gameLoop);
    } else {
      this.gameLoop = setInterval(() => this.update(), this.state.speed);
    }
  }

  update() {
    if (this.state.isDead) {
      this.handleDeathAnimation();
      return;
    }

    if (this.state.isPaused) return;

    this.spawnEntities();
    this.updateEntities();
    this.checkCollisions();
    this.updateScore();
    this.render();
  }

  checkCollisions() {
    const playerHitbox = {
      x: this.state.currentLane,
      y: this.state.isJumping ? CONFIG.GAME.CYCLIST_Y - 1 : CONFIG.GAME.CYCLIST_Y,
      width: ENTITIES.BIKE.width,
      height: ENTITIES.BIKE.height,
    };

    const collision = this.collisionManager.checkPlayerCollision(
      playerHitbox,
      {
        obstacles: this.obstacleManager.obstacles,
        parkedCars: this.obstacleManager.parkedCars,
      },
      this.state.isJumping
    );

    if (collision) {
      this.die(collision);
    }
  }

  // Entity Management
  spawnEntities() {
    this.obstacleManager.spawn();
  }

  updateEntities() {
    this.obstacleManager.update();
    this.collisionManager.update();
  }

  // Rendering
  createGrid() {
    return Array(CONFIG.GAME.HEIGHT)
      .fill()
      .map(() => Array(CONFIG.GAME.WIDTH).fill(" "));
  }

  render() {
    if (this.state.isDead && this.state.deathAnimation >= 10) return;

    this.grid = this.createGrid();
    this.drawRoadFeatures();
    this.drawEntities();
    this.drawPlayer();

    const gameScreen = document.getElementById("game-screen");
    if (gameScreen) {
      gameScreen.innerHTML = this.grid
        .map(row => row.map(cell => `<span class="grid-cell">${cell}</span>`).join(""))
        .join("<br />");
    }
  }

  drawRoadFeatures() {
    for (let y = 0; y < CONFIG.GAME.HEIGHT; y++) {
      this.grid[y][CONFIG.LANES.DIVIDER] = STYLES.TRAFFIC + "║" + STYLES.RESET;
      this.grid[y][CONFIG.LANES.DIVIDER + 1] = STYLES.TRAFFIC + "║" + STYLES.RESET;
      this.grid[y][CONFIG.LANES.TRACKS + 1] = STYLES.TRACKS + "║" + STYLES.RESET;
      this.grid[y][CONFIG.LANES.TRACKS + 5] = STYLES.TRACKS + "║" + STYLES.RESET;

      if (y % 3 === 0) {
        this.grid[y][CONFIG.LANES.BIKE - 1] = STYLES.TRAFFIC + " " + STYLES.RESET;
      }

      for (let x = CONFIG.LANES.SIDEWALK; x < CONFIG.LANES.SHOPS; x++) {
        this.grid[y][x] = STYLES.SIDEWALK + " " + STYLES.RESET;
      }
    }
  }

  drawEntities() {
    this.obstacleManager.getAllObjects().forEach(entity => {
      this.drawEntity(entity, entity.type === "PEDESTRIAN" ? STYLES.SIDEWALK : entity.color);
    });
  }

  drawEntity(entity, style) {
    if (entity.y + entity.height >= 0 && entity.y < CONFIG.GAME.HEIGHT) {
      entity.art.forEach((line, i) => {
        if (entity.y + i >= 0 && entity.y + i < CONFIG.GAME.HEIGHT) {
          line.split("").forEach((char, x) => {
            if (char !== " " && entity.x + x >= 0 && entity.x + x < CONFIG.GAME.WIDTH) {
              this.grid[Math.floor(entity.y + i)][entity.x + x] = style + char + STYLES.RESET;
            }
          });
        }
      });
    }
  }

  drawPlayer() {
    if (this.state.isDead && this.state.deathAnimation < 10) {
      ENTITIES.EXPLOSION.art.forEach((line, i) => {
        line.split("").forEach((char, x) => {
          if (this.deathY + i < CONFIG.GAME.HEIGHT) {
            this.grid[this.deathY + i][this.deathX + x] = STYLES.TRAFFIC + char + STYLES.RESET;
          }
        });
      });
    } else if (!this.state.isDead) {
      const bikeY = this.state.isJumping ? CONFIG.GAME.CYCLIST_Y - 1 : CONFIG.GAME.CYCLIST_Y;
      ENTITIES.BIKE.art.forEach((line, i) => {
        line.split("").forEach((char, x) => {
          if (char !== " ") {
            this.grid[bikeY + i][this.state.currentLane + x] = STYLES.BIKE + char + STYLES.RESET;
          }
        });
      });
    }
  }

  // Death Handling
  die(reason) {
    this.state.isDead = true;
    this.deathX = this.state.currentLane;
    this.deathY = CONFIG.GAME.CYCLIST_Y;

    this.flashScreen();
    this.showDeathMessage(reason);

    setTimeout(() => {
      const messageEl = document.getElementById("mainMessageBox");
      if (messageEl) {
        messageEl.classList.remove("show-message");
      }
      this.restart();
    }, 3000);
  }

  flashScreen() {
    const gameScreen = document.getElementById("game-screen");
    if (!gameScreen) return;

    const colors = ["#FF0000", "#000000", "#222"];
    let delay = 0;

    colors.forEach(color => {
      setTimeout(() => {
        gameScreen.style.backgroundColor = color;
      }, delay);
      delay += 100;
    });
  }

  showDeathMessage(reason) {
    const messageEl = document.getElementById("mainMessageBox");
    if (!messageEl) return;

    const randomMessage = this.getRandomDeathMessage(reason);
    const randomFace = cuteDeathFaces[Math.floor(Math.random() * cuteDeathFaces.length)];

    messageEl.innerHTML = `
      <span class="message-reason">${randomMessage.reason}</span><br /><br />
      ${randomMessage.funny}<br /><br />
      <span class="cute-face">${randomFace}</span>
    `;
    messageEl.style.display = "block";
  }

  getRandomDeathMessage(type) {
    const messages = MESSAGES.DEATH[type];
    if (!messages?.length) {
      return {
        reason: "X X!",
        funny: "Sometimes things just happen"
      };
    }
    return messages[Math.floor(Math.random() * messages.length)];
  }

  // Game Reset
  restart() {
    Building.resetSpawnPosition();
    this.collisionManager = new CollisionManager(CONFIG);
    this.obstacleManager = new ObstacleManager(CONFIG, this.collisionManager);
    this.initializeState();
    this.start();
    
    const messageBox = document.getElementById("mainMessageBox");
    if (messageBox) {
      messageBox.textContent = MESSAGES.GAME.START;
    }
  }

  handleDeathAnimation() {
    this.state.deathAnimation++;
    if (this.state.deathAnimation > 10) {
      this.state.isPlaying = false;
      clearInterval(this.gameLoop);
      return;
    }
    this.render();
  }

  updateScore() {
    this.state.score++;
    
    const scoreElement = document.getElementById("time-alive");
    if (scoreElement) {
      scoreElement.textContent = `STAY ALIVE? ${this.state.score}`;
    }

    this.state.speed = Math.max(
      this.state.speed * CONFIG.GAME.SPEED_DECREASE_RATE,
      CONFIG.GAME.MIN_SPEED
    );

    clearInterval(this.gameLoop);
    this.gameLoop = setInterval(() => this.update(), this.state.speed);
  }

  // Cleanup
  cleanup() {
    clearInterval(this.gameLoop);
    // Add any additional cleanup needed
  }
}      /////////////////////////////////////////
      /////////////////////////////////////////
      ///////////SETTINGS WINDOW /////////////
      ////////////////////////////////////////
      ////////////////////////////////////////

      // Toggle settings window visibility with "D" key
      document.addEventListener("keydown", (e) => {
        if (e.key.toLowerCase() === "d") {
          const settingsWindow = document.getElementById("settings-window");
          settingsWindow.style.display = settingsWindow.style.display === "none" ? "block" : "none";
        }
      });

      // Update configuration values and display value on input change
      document.getElementById("pedestrian-speed").addEventListener("input", (e) => {
        CONFIG.PEDESTRIAN.SPEED = parseFloat(e.target.value);
        document.getElementById("pedestrian-speed-value").textContent = e.target.value;
      });

      document.getElementById("streetcar-spawn-rate").addEventListener("input", (e) => {
        CONFIG.SPAWN_RATES.STREETCAR = parseFloat(e.target.value);
        document.getElementById("streetcar-spawn-rate-value").textContent = e.target.value;
      });

      document.getElementById("oncoming-car-spawn-rate").addEventListener("input", (e) => {
        CONFIG.SPAWN_RATES.ONCOMING_CAR = parseFloat(e.target.value);
        document.getElementById("oncoming-car-spawn-rate-value").textContent = e.target.value;
      });

      document.getElementById("parked-car-spawn-rate").addEventListener("input", (e) => {
        CONFIG.SPAWN_RATES.PARKED_CAR = parseFloat(e.target.value);
        document.getElementById("parked-car-spawn-rate-value").textContent = e.target.value;
      });

      document.getElementById("streetcar-lane-car-spawn-rate").addEventListener("input", (e) => {
        CONFIG.SPAWN_RATES.STREETCAR_LANE_CAR = parseFloat(e.target.value);
        document.getElementById("streetcar-lane-car-spawn-rate-value").textContent = e.target.value;
      });

      document.getElementById("pedestrian-spawn-rate").addEventListener("input", (e) => {
        CONFIG.SPAWN_RATES.PEDESTRIAN = parseFloat(e.target.value);
        document.getElementById("pedestrian-spawn-rate-value").textContent = e.target.value;
      });

      document.getElementById("initial-speed").addEventListener("input", (e) => {
        CONFIG.GAME.INITIAL_SPEED = parseInt(e.target.value);
        document.getElementById("initial-speed-value").textContent = e.target.value;
      });

      document.getElementById("min-speed").addEventListener("input", (e) => {
        CONFIG.GAME.MIN_SPEED = parseInt(e.target.value);
        document.getElementById("min-speed-value").textContent = e.target.value;
      });

      document.getElementById("speed-decrease-rate").addEventListener("input", (e) => {
        CONFIG.GAME.SPEED_DECREASE_RATE = parseFloat(e.target.value);
        document.getElementById("speed-decrease-rate-value").textContent = e.target.value;
      });

      // Vehicle Gap Controls
      document.getElementById("streetcar-gap").addEventListener("input", (e) => {
        CONFIG.SAFE_DISTANCE.STREETCAR = parseInt(e.target.value);
        document.getElementById("streetcar-gap-value").textContent = e.target.value;
      });

      document.getElementById("lane-car-gap").addEventListener("input", (e) => {
        CONFIG.SAFE_DISTANCE.STREETCAR_LANE_CAR = parseInt(e.target.value);
        document.getElementById("lane-car-gap-value").textContent = e.target.value;
      });

      document.getElementById("oncoming-car-gap").addEventListener("input", (e) => {
        CONFIG.SAFE_DISTANCE.ONCOMING_CAR = parseInt(e.target.value);
        document.getElementById("oncoming-car-gap-value").textContent = e.target.value;
      });

      // Lane Width and Cyclist Speed Controls
      document.getElementById("lane-width").addEventListener("input", (e) => {
        CONFIG.GAME.WIDTH = parseInt(e.target.value);
        document.getElementById("lane-width-value").textContent = e.target.value;
      });

      document.getElementById("cyclist-speed").addEventListener("input", (e) => {
        game.state.movementSpeed = parseInt(e.target.value);
        document.getElementById("cyclist-speed-value").textContent = e.target.value;
      });
    </script>
    <script src="shops.js"></script>
    <script src="cuteDeathFaces.js"></script>
    <script src="colours.js"></script>
    <script src="assets.js"></script>
    <script src="messages.js"></script>
    <script src="config.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const game = new LoserLane();
      });
    </script>
  </body>
</html>
