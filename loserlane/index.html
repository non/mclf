<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Toronto Cyclist</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div id="game-container">
      <!-- Settings Window -->
      <div id="settings-window">
        <h3>Game Settings</h3>

        <!-- Pedestrian Speed -->
        <label for="pedestrian-speed"
          >Pedestrian Speed
          <span id="pedestrian-speed-value" class="value-display">0.5</span>
        </label>
        <input id="pedestrian-speed" type="range" min="0.1" max="3" step="0.1" value="0.5" />

        <!-- Spawn Rates -->
        <label for="streetcar-spawn-rate"
          >Streetcar Spawn Rate
          <span id="streetcar-spawn-rate-value" class="value-display">0.03</span>
        </label>
        <input id="streetcar-spawn-rate" type="range" min="0.01" max="1" step="0.01" value="0.03" />

        <label for="oncoming-car-spawn-rate"
          >Oncoming Car Spawn Rate
          <span id="oncoming-car-spawn-rate-value" class="value-display">0.15</span>
        </label>
        <input id="oncoming-car-spawn-rate" type="range" min="0.01" max="1" step="0.01" value="0.15" />

        <label for="parked-car-spawn-rate"
          >Parked Car Spawn Rate
          <span id="parked-car-spawn-rate-value" class="value-display">0.15</span>
        </label>
        <input id="parked-car-spawn-rate" type="range" min="0.01" max="1" step="0.01" value="0.15" />

        <label for="streetcar-lane-car-spawn-rate"
          >Streetcar Lane Car Spawn Rate
          <span id="streetcar-lane-car-spawn-rate-value" class="value-display">0.3</span>
        </label>
        <input id="streetcar-lane-car-spawn-rate" type="range" min="0.01" max="1" step="0.01" value="0.3" />

        <label for="pedestrian-spawn-rate"
          >Pedestrian Spawn Rate
          <span id="pedestrian-spawn-rate-value" class="value-display">0.05</span>
        </label>
        <input id="pedestrian-spawn-rate" type="range" min="0.01" max="1" step="0.01" value="0.05" />

        <!-- Game Speed Controls -->
        <label for="initial-speed"
          >Initial Game Speed
          <span id="initial-speed-value" class="value-display">500</span>
        </label>
        <input id="initial-speed" type="range" min="100" max="1000" step="10" value="500" />

        <label for="min-speed"
          >Minimum Game Speed
          <span id="min-speed-value" class="value-display">300</span>
        </label>
        <input id="min-speed" type="range" min="100" max="1000" step="10" value="300" />

        <label for="speed-decrease-rate"
          >Speed Decrease Rate
          <span id="speed-decrease-rate-value" class="value-display">0.995</span>
        </label>
        <input id="speed-decrease-rate" type="range" min="0.9" max="1" step="0.001" value="0.995" />

        <!-- Gaps Between Vehicles -->
        <label for="streetcar-gap"
          >Streetcar Gap
          <span id="streetcar-gap-value" class="value-display">20</span>
        </label>
        <input id="streetcar-gap" type="range" min="10" max="50" step="1" value="20" />

        <label for="lane-car-gap"
          >Streetcar Lane Car Gap
          <span id="lane-car-gap-value" class="value-display">12</span>
        </label>
        <input id="lane-car-gap" type="range" min="10" max="50" step="1" value="12" />

        <label for="oncoming-car-gap"
          >Oncoming Car Gap
          <span id="oncoming-car-gap-value" class="value-display">8</span>
        </label>
        <input id="oncoming-car-gap" type="range" min="5" max="30" step="1" value="8" />

        <!-- Lane Widths and Cyclist Speed -->
        <label for="lane-width"
          >Lane Width
          <span id="lane-width-value" class="value-display">45</span>
        </label>
        <input id="lane-width" type="range" min="20" max="60" step="1" value="45" />

        <label for="cyclist-speed"
          >Cyclist Speed
          <span id="cyclist-speed-value" class="value-display">100</span>
        </label>
        <input id="cyclist-speed" type="range" min="50" max="200" step="5" value="100" />
      </div>

      <div id="game-screen"></div>
      <div id="mainMessageBox">
        <!-- <span id="gameTitle">L O S E R ~ L A N E</span><br /><br /> -->

        CLICK or SPACEBAR to start<br /><br />
        LEFT/RIGHT arrow keys or CLICK sides to move<br /><br />
        DOUBLE-TAP to jump tracks!
      </div>
      <br />
      <div id="controls">
        <div class="control-area" id="move-left"></div>
        <div class="control-area" id="move-right"></div>
      </div>
      <div class="info-box">
        <!-- <div id="title">L O S E R ~ L A N E</div>
        <div id="time-alive">STAY ALIVE 0</div> -->

        <div id="title-container">
          <div class="bike-art-left">
            __o <br />
            _ \<_ <br />
            (_)/(_)
          </div>

          <div class="title-text">
            <div id="title">L O S E R ~ L A N E</div>
            <div id="time-alive">STAY ALIVE? 0</div>
          </div>

          <div class="bike-art-right">
            o__ <br />
            _ >/ _ <br />
            (_) \(_)
          </div>
        </div>
      </div>
    </div>

    <script>
      // Constants and Configuration
      const CONFIG = {
        GAME: {
          WIDTH: 45,
          HEIGHT: Math.floor(window.innerHeight / 20), // Adjust this divisor to control the height scaling
          INITIAL_SPEED: 20,
          MIN_SPEED: 300,
          SPEED_DECREASE_RATE: 0.995,
          CYCLIST_Y: Math.floor(window.innerHeight / 40), // Adjust this to control the cyclist's starting position
          DOUBLE_TAP_TIME: 350,
        },
        SPAWN_RATES: {
          STREETCAR: 0.03,
          STREETCAR_LANE_CAR: 0.3,
          ONCOMING_CAR: 0.15,
          PARKED_CAR: 0.15,
          DOOR_OPENING: 0.1,
          PEDESTRIAN: 0.05, // Spawn rate for pedestrians
        },
        PEDESTRIAN: {
          SPEED: 0.5, // Speed for pedestrians
          // ART: ENTITIES.PEDESTRIAN
        },
        LANES: {
          ONCOMING: 2,
          DIVIDER: 8,
          TRACKS: 12,
          BIKE: 19,
          BIKE_RIGHT: 20,
          PARKED: 22,
          SIDEWALK: 30,
          SHOPS: 34,
        },
      };

      // Base Obstacle class
      class BaseObstacle {
        constructor(x, y, template, config) {
          this.type = template.type;
          this.art = template.art;
          this.x = x;
          this.y = y;
          this.width = template.width;
          this.height = template.height;
          this.speed = template.speed || 0;
          this.color = template.color || STYLES.RESET;
          this.config = config;

          this.hitbox = {
            x: x,
            y: y,
            width: template.width,
            height: template.height,
          };
        }

        update() {
          // Default update behavior
          const updatedY = this.y + this.speed;
          this.y = updatedY;
          this.hitbox.y = updatedY;
          return this.isOnScreen();
        }

        isOnScreen() {
          return this.speed > 0 ? this.y < this.config.GAME.HEIGHT + 2 : this.y + this.height > -2;
        }
      }

      class Streetcar extends BaseObstacle {
        constructor(config, collisionManager) {
          const spawnConfig = collisionManager.getSpawnConfig("streetcar");
          super(
            spawnConfig.x,
            spawnConfig.y,
            {
              type: "STREETCAR",
              art: ENTITIES.STREETCAR.art,
              width: ENTITIES.STREETCAR.width,
              height: ENTITIES.STREETCAR.height,
              speed: spawnConfig.speed,
              color: STYLES.TTC,
            },
            config
          );
          this.collisionManager = collisionManager;
          // console.log(`Creating ${this.type} at position (${this.x}, ${this.y}) with speed ${spawnConfig.speed}`);
        }

        update() {
          const updatedY = this.y - 1;
          this.y = updatedY;
          this.hitbox.y = updatedY;

          const vehicle = this.collisionManager.laneOccupancy.streetcar.find((v) => v.y === this.y);
          if (vehicle) {
            vehicle.y = updatedY;
          }
          return this.y + this.height > -2;
        }
      }

      class StreetcarLaneCar extends BaseObstacle {
        constructor(config, collisionManager) {
          const spawnConfig = collisionManager.getSpawnConfig("streetcarLaneCar");
          const vehicleColor = COLORS.VEHICLES[Math.floor(Math.random() * COLORS.VEHICLES.length)];

          super(
            spawnConfig.x,
            spawnConfig.y,
            {
              type: "STREETCAR_LANE_CAR",
              art: ENTITIES.MOVINGCAR.art,
              width: ENTITIES.MOVINGCAR.width,
              height: ENTITIES.MOVINGCAR.height,
              speed: spawnConfig.speed,
              color: `<span style='color: ${vehicleColor}'>`,
            },
            config
          );
          this.collisionManager = collisionManager;
        }
      }

      class OncomingCar extends BaseObstacle {
        constructor(config, collisionManager) {
          const spawnConfig = collisionManager.getSpawnConfig("oncoming");
          const vehicleColor = COLORS.VEHICLES[Math.floor(Math.random() * COLORS.VEHICLES.length)];

          super(
            spawnConfig.x,
            spawnConfig.y,
            {
              type: "CAR",
              art: ENTITIES.ONCOMINGCAR.art,
              width: ENTITIES.ONCOMINGCAR.width,
              height: ENTITIES.ONCOMINGCAR.height,
              speed: spawnConfig.speed,
              color: `<span style='color: ${vehicleColor}'>`,
            },
            config
          );
          this.collisionManager = collisionManager;
        }
      }

      class ParkedCar extends BaseObstacle {
        constructor(config, collisionManager) {
          const spawnConfig = collisionManager.getSpawnConfig("parked");
          const vehicleColor = COLORS.VEHICLES[Math.floor(Math.random() * COLORS.VEHICLES.length)];
          const state0Art = ENTITIES.PARKED_CAR_STATES[0];

          super(
            config.LANES.PARKED,
            spawnConfig.y,
            {
              type: "PARKED",
              art: state0Art,
              width: 7, // Width of actual car body without spaces
              height: 5, // Height of car
              speed: 1,
              color: `<span style='color: ${vehicleColor}'>`,
            },
            config
          );

          this.collisionManager = collisionManager;

          // Define the primary hitbox for the car body without spaces and door
          this.hitbox = {
            x: config.LANES.PARKED + 2, // Offset by 2 if car has leading spaces in art
            y: spawnConfig.y,
            width: 4, // Width of car body without door
            height: 5, // Height of car body
          };

          // Door hitbox remains undefined until door starts opening
          this.doorHitbox = null;
          this.doorState = 0;
          this.isDoored = false;
        }

        update() {
          const updatedY = this.y + 1;
          this.y = updatedY;
          this.hitbox.y = updatedY;

          // Update door hitbox if it exists
          if (this.doorHitbox) {
            this.doorHitbox.y = updatedY + 1;
          }

          return this.y < this.config.GAME.HEIGHT + 2;
        }

        updateDoor() {
          // Check if we should start opening the door
          if (!this.isDoored && this.y > 0 && this.y < this.config.GAME.HEIGHT - 10 && Math.random() < this.config.SPAWN_RATES.DOOR_OPENING) {
            this.isDoored = true;
            this.doorState = 0;
          }

          // Only adjust the door hitbox if door is opening
          if (this.isDoored && this.doorState < ENTITIES.PARKED_CAR_STATES.length - 1) {
            this.doorState++;
            this.art = ENTITIES.PARKED_CAR_STATES[this.doorState];

            // Set door hitbox based on the current door state
            const doorWidths = [0, 0.8, 1, 1.5, 1.8]; // Define incremental door widths for each state
            const doorWidth = doorWidths[this.doorState];

            this.doorHitbox = {
              x: this.hitbox.x - doorWidth, // Position door hitbox next to the car body
              y: this.y + 1, // Align vertically with car body
              width: doorWidth,
              height: 1.8, // Adjust height based on door height in art
            };
          }
        }
      }

      class Pedestrian extends BaseObstacle {
        constructor(config, isGoingUp) {
          const template = isGoingUp ? ENTITIES.PEDESTRIAN.UP : ENTITIES.PEDESTRIAN.DOWN;
          super(
            config.LANES.SIDEWALK,
            isGoingUp ? config.GAME.HEIGHT : -1,
            {
              type: "PEDESTRIAN",
              art: template.art,
              width: template.width,
              height: template.height,
              speed: config.PEDESTRIAN.SPEED * (isGoingUp ? -1 : 1),
            },
            config
          );
        }

        update() {
          const updatedY = this.y + this.speed;
          this.y = updatedY;
          this.hitbox.y = updatedY;
          return this.speed > 0 ? this.y < this.config.GAME.HEIGHT + 2 : this.y + this.height > -2;
        }
      }

      class ObstacleManager {
        constructor(config, collisionManager, entities) {
          this.config = config;
          this.collisionManager = collisionManager;
          this.obstacles = [];
          this.parkedCars = [];
        }

        update() {
          // Update and filter obstacles
          this.obstacles = this.obstacles.filter((obstacle) => obstacle.update());

          // Update and filter parked cars
          this.parkedCars = this.parkedCars.filter((car) => {
            const stillOnScreen = car.update();
            car.updateDoor();
            return stillOnScreen;
          });
        }

        spawn() {
          // Streetcar spawn
          if (Math.random() < this.config.SPAWN_RATES.STREETCAR) {
            // console.log("Attempting streetcar spawn...");
            const spawnConfig = this.collisionManager.getSpawnConfig("streetcar");
            if (this.collisionManager.canSpawn("streetcar", spawnConfig.y)) {
              // console.log("Streetcar spawn successful");
              const streetcar = new Streetcar(this.config, this.collisionManager);
              this.collisionManager.addVehicle("streetcar", streetcar);
              this.obstacles.push(streetcar);
            } else {
              // console.log("Streetcar spawn blocked");
            }
          }

          // Streetcar lane car spawn
          if (Math.random() < this.config.SPAWN_RATES.STREETCAR_LANE_CAR) {
            // console.log("Attempting streetcar lane car spawn...");
            const spawnConfig = this.collisionManager.getSpawnConfig("streetcarLaneCar");
            if (this.collisionManager.canSpawn("streetcarLaneCar", spawnConfig.y)) {
              // console.log("Streetcar lane car spawn successful");
              const car = new StreetcarLaneCar(this.config, this.collisionManager);
              this.collisionManager.addVehicle("streetcarLaneCar", car);
              this.obstacles.push(car);
            } else {
              // console.log("Streetcar lane car spawn blocked");
            }
          }

          // Oncoming car spawn
          if (Math.random() < this.config.SPAWN_RATES.ONCOMING_CAR) {
            // console.log("Attempting oncoming car spawn...");
            const spawnConfig = this.collisionManager.getSpawnConfig("oncoming");
            if (this.collisionManager.canSpawn("oncoming", spawnConfig.y)) {
              // console.log("Oncoming car spawn successful");
              const car = new OncomingCar(this.config, this.collisionManager);
              this.collisionManager.addVehicle("oncoming", car);
              this.obstacles.push(car);
            } else {
              // console.log("Oncoming car spawn blocked");
            }
          }

          // Parked car spawn
          if (Math.random() < this.config.SPAWN_RATES.PARKED_CAR) {
            const spawnConfig = this.collisionManager.getSpawnConfig("parked");
            if (this.collisionManager.canSpawn("parked", spawnConfig.y)) {
              const car = new ParkedCar(this.config, this.collisionManager);
              this.collisionManager.addVehicle("parked", car);
              this.parkedCars.push(car);
            }
          }

          // Pedestrian spawn
          if (Math.random() < this.config.SPAWN_RATES.PEDESTRIAN) {
            const isGoingUp = Math.random() > 0.5;
            const pedestrian = new Pedestrian(this.config, isGoingUp);
            this.obstacles.push(pedestrian); // Add pedestrian directly to obstacles
          }
        }

        getAllObjects() {
          return [...this.obstacles, ...this.parkedCars];
        }
      }

      class CollisionManager {
        constructor(config) {
          this.config = config;
          // Track active entities by lane
          this.laneOccupancy = {
            streetcar: [], // Tracks lane
            streetcarLaneCar: [], // Next to tracks
            oncoming: [], // Oncoming traffic
            parked: [], // Parked cars
          };

          // Minimum safe distance between vehicles in the same lane
          this.safeDistance = {
            streetcar: 20, // Streetcars need more space
            streetcarLaneCar: 12,
            oncoming: 8,
            parked: 10,
          };

          this.shopHitboxes = []; // Array to hold shop hitboxes
        }

        addShopHitbox(hitbox) {
          this.shopHitboxes.push(hitbox);
        }

        // Check for collisions with shops
        checkShopCollision(playerHitbox) {
          return this.shopHitboxes.some((shop) => this.checkOverlap(playerHitbox, shop));
        }

        // Utility function to check if two hitboxes overlap
        checkOverlap(boxA, boxB) {
          return !(
            boxA.x + boxA.width <= boxB.x ||
            boxA.x >= boxB.x + boxB.width ||
            boxA.y + boxA.height <= boxB.y ||
            boxA.y >= boxB.y + boxB.height
          );
        }

        // Check if it's safe to spawn a new vehicle
        // In CollisionManager class
        canSpawn(type, yPosition) {
          const minDistance = this.safeDistance[type];

          // If there are no vehicles in any relevant lanes, allow spawning
          if (this.laneOccupancy[type].length === 0) {
            // For streetcar lane cars, also check streetcars
            if (type === "streetcarLaneCar") {
              return this.laneOccupancy["streetcar"].every((streetcar) => Math.abs(streetcar.y - yPosition) > minDistance);
            }
            // For streetcars, also check streetcar lane cars
            if (type === "streetcar") {
              return this.laneOccupancy["streetcarLaneCar"].every((car) => Math.abs(car.y - yPosition) > minDistance);
            }
            return true;
          }

          // Check distance to vehicles in the same lane
          const isSafeSameLane = this.laneOccupancy[type].every((vehicle) => Math.abs(vehicle.y - yPosition) > minDistance);

          // Additional checks for vehicles that share lanes
          if (type === "streetcarLaneCar" || type === "streetcar") {
            const otherType = type === "streetcar" ? "streetcarLaneCar" : "streetcar";
            const isSafeOtherLane = this.laneOccupancy[otherType].every((vehicle) => Math.abs(vehicle.y - yPosition) > minDistance);
            return isSafeSameLane && isSafeOtherLane;
          }

          return isSafeSameLane;
        }

        // Add vehicle to tracking
        addVehicle(type, vehicle) {
          this.laneOccupancy[type].push(vehicle);
        }

        // Update positions and remove out-of-bounds vehicles
        update() {
          // Update each lane's occupancy
          Object.keys(this.laneOccupancy).forEach((type) => {
            this.laneOccupancy[type] = this.laneOccupancy[type].filter((vehicle) => {
              // Remove if out of bounds
              if (vehicle.speed > 0) {
                return vehicle.y < this.config.GAME.HEIGHT + 2;
              } else {
                return vehicle.y + vehicle.height > -2;
              }
            });
          });
        }

        // Get spawn configuration for different vehicle types
        getSpawnConfig(type) {
          const configs = {
            streetcar: {
              x: this.config.LANES.TRACKS,
              y: this.config.GAME.HEIGHT + 1,
              speed: -1,
            },
            streetcarLaneCar: {
              x: this.config.LANES.TRACKS + 1,
              y: this.config.GAME.HEIGHT + 1,
              speed: -1,
            },
            oncoming: {
              x: this.config.LANES.ONCOMING,
              y: -10,
              speed: 2,
            },
            parked: {
              x: this.config.LANES.PARKED,
              y: -5,
              speed: 1,
            },
          };
          return configs[type];
        }

        // Check player collisions (returns collision type or null)
        checkPlayerCollision(playerHitbox, entities, isJumping) {
          if (this.checkCarBodyCollision(playerHitbox, entities.parkedCars)) {
            console.log("Collision detected with: PARKEDCAR");
            return "PARKEDCAR";
          }

          if (this.checkDoorCollision(playerHitbox, entities.parkedCars)) {
            console.log("Collision detected with: DOOR");
            return "DOOR";
          }

          if (!isJumping && this.checkStreetcarCollision(playerHitbox, entities.obstacles)) {
            console.log("Collision detected with: STREETCAR");
            return "STREETCAR";
          }

          // Modify this line to specifically check for pedestrian collisions
          const obstacleCollision = this.checkObsCollision(playerHitbox, entities.obstacles);
          if (obstacleCollision) {
            // console.log(`Collision detected with: ${obstacleCollision}`);
            return obstacleCollision; // Now this can return "PEDESTRIAN" if it’s a pedestrian
          }

          if (this.checkShopCollision(playerHitbox)) {
            // console.log("Collision detected with: SHOP");
            return "SHOP";
          }

          if (this.checkTrackCollision(playerHitbox)) {
            // console.log("Collision detected with: TRACKS");
            return "TRACKS";
          }

          console.log("No collision detected");
          return null;
        }

        // Individual collision checks
        checkTrackCollision(playerHitbox) {
          const trackPositions = [this.config.LANES.TRACKS + 1, this.config.LANES.TRACKS + 5];

          const playerCenter = playerHitbox.x + Math.floor(playerHitbox.width / 2);
          return trackPositions.includes(playerCenter);
        }

        checkStreetcarCollision(playerHitbox, obstacles) {
          const collision = obstacles
            .filter((obs) => obs.type === "STREETCAR")
            .some((streetcar) => this.checkOverlap(playerHitbox, streetcar.hitbox));
          if (collision) console.log("checkStreetcarCollision: Collision with streetcar");
          return collision;
        }

        checkObsCollision(playerHitbox, obstacles) {
          const collision = obstacles.find((obstacle) => {
            const isCollision = this.checkOverlap(playerHitbox, obstacle.hitbox);
            if (isCollision) {
              // console.log(`Collision detected with: ${obstacle.type}`);
              return obstacle.type; // Return the obstacle type directly
            }
            return false;
          });
          return collision ? collision.type : null; // Return null if no collision is found
        }

        checkPedestrianCollision(playerHitbox, obstacles) {
          // const collision = obstacles.some((obstacle) => {
          //   const isCollision = this.checkOverlap(playerHitbox, obstacle.hitbox);
          //   if (isCollision) {
          //     console.log(`Collision detected with: ${obstacle.type}`);
          //   }
          //   return isCollision;
          // });
          // return collision;
        }

        checkDoorCollision(playerHitbox, parkedCars) {
          const collision = parkedCars.some((car) => car.doorState > 0 && car.doorHitbox && this.checkOverlap(playerHitbox, car.doorHitbox));
          if (collision) console.log("checkDoorCollision: Collision with parked car door");
          return collision;
        }

        checkCarBodyCollision(playerHitbox, parkedCars) {
          const collision = parkedCars.some((car) => this.checkOverlap(playerHitbox, car.hitbox));
          if (collision) console.log("checkCarBodyCollision: Collision with parked car body");
          return collision;
        }

        checkShopCollision(playerHitbox) {
          return this.checkOverlap(playerHitbox, {
            x: this.config.LANES.SHOPS,
            y: 0,
            width: this.config.GAME.WIDTH - this.config.LANES.SHOPS,
            height: this.config.GAME.HEIGHT,
          });
        }

        // Utility function to check if two hitboxes overlap
        checkOverlap(boxA, boxB) {
          return !(
            boxA.x + boxA.width <= boxB.x ||
            boxA.x >= boxB.x + boxB.width ||
            boxA.y + boxA.height <= boxB.y ||
            boxA.y >= boxB.y + boxB.height
          );
        }
      }

      // Main Game Class
      class LoserLane {
        constructor() {
          this.collisionManager = new CollisionManager(CONFIG);
          this.obstacleManager = new ObstacleManager(CONFIG, this.collisionManager);
          this.initializeState();
          this.setupControls();
          this.grid = this.createGrid();
        }

        createGrid() {
          return Array(CONFIG.GAME.HEIGHT)
            .fill()
            .map(() => Array(CONFIG.GAME.WIDTH).fill(" "));
        }

        initializeState() {
          this.state = {
            isDead: false,
            score: 0,
            currentLane: CONFIG.LANES.BIKE,
            speed: CONFIG.GAME.INITIAL_SPEED,
            deathAnimation: 0,
            lastTap: 0,
            doubleTapActive: false,
            isJumping: false,
            moveInterval: null,
            movementSpeed: 100,
            isMovingLeft: false,
            isMovingRight: false,
            lastKeyPress: 0,
            isPlaying: false,
          };
          this.entities = {
            obstacles: [],
            parkedCars: [],
          };
        }

        setupControls() {
          document.addEventListener("keydown", (e) => {
            if (!this.state.isPlaying) {
              this.start();
              return;
            }

            if (e.key === "ArrowLeft") {
              this.moveLeft();
            }

            if (e.key === "ArrowRight") {
              this.moveRight();
            }
          });
        }

        moveLeft() {
          if (this.state.isDead) return;

          const now = Date.now();
          const isDoubleTap = now - this.state.lastTap < CONFIG.GAME.DOUBLE_TAP_TIME;

          if (isDoubleTap) {
            const newLane = Math.max(this.state.currentLane - 2, CONFIG.LANES.ONCOMING);
            this.state.currentLane = newLane;
            this.state.isJumping = true;

            setTimeout(() => {
              this.state.isJumping = false;
            }, 200);
          } else {
            const newLane = Math.max(this.state.currentLane - 1, CONFIG.LANES.ONCOMING);
            this.state.currentLane = newLane;
            this.state.isJumping = false;
          }

          this.state.lastTap = now;
        }

        moveRight() {
          if (this.state.isDead) return;

          const now = Date.now();
          const isDoubleTap = now - this.state.lastTap < CONFIG.GAME.DOUBLE_TAP_TIME;

          if (isDoubleTap) {
            const newLane = Math.min(this.state.currentLane + 2, CONFIG.LANES.SHOPS - 1);
            this.state.currentLane = newLane;
            this.state.isJumping = true;

            setTimeout(() => {
              this.state.isJumping = false;
            }, 200);
          } else {
            const newLane = Math.min(this.state.currentLane + 1, CONFIG.LANES.SHOPS - 1);
            this.state.currentLane = newLane;
            this.state.isJumping = false;
          }

          this.state.lastTap = now;
        }

        start() {
          if (this.state.isPlaying) return;

          document.getElementById("mainMessageBox").style.display = "none";
          this.state.isPlaying = true;
          this.gameLoop = setInterval(() => this.update(), this.state.speed);
        }

        update() {
          if (this.state.isDead) {
            this.handleDeathAnimation();
            return;
          }

          this.spawnEntities();
          this.updateEntities();

          // Create player hitbox
          const playerHitbox = {
            x: this.state.currentLane,
            y: this.state.isJumping ? CONFIG.GAME.CYCLIST_Y - 1 : CONFIG.GAME.CYCLIST_Y,
            width: ENTITIES.BIKE.width,
            height: ENTITIES.BIKE.height,
          };

          // Check for collisions
          const collision = this.collisionManager.checkPlayerCollision(
            playerHitbox,
            {
              obstacles: this.obstacleManager.obstacles,
              parkedCars: this.obstacleManager.parkedCars,
            },
            this.state.isJumping
          );
          if (collision) {
            this.die(collision);
          }

          this.updateScore();
          this.render();
        }

        spawnEntities() {
          this.obstacleManager.spawn();
        }

        updateEntities() {
          this.obstacleManager.update();
          this.collisionManager.update();
        }

        render() {
          if (this.state.isDead && this.deathAnimation >= 10) return;

          this.grid = this.createGrid();
          this.drawRoadFeatures();
          this.drawShops();
          this.drawEntities();
          // this.drawHitboxes();
          this.drawPlayer();

          const gameScreen = document.getElementById("game-screen");
          gameScreen.innerHTML = this.grid.map((row) => row.map((cell) => `<span class="grid-cell">${cell}</span>`).join("")).join("<br />");
        }

        drawRoadFeatures() {
          for (let y = 0; y < CONFIG.GAME.HEIGHT; y++) {
            this.grid[y][CONFIG.LANES.DIVIDER] = STYLES.TRAFFIC + "║" + STYLES.RESET;
            this.grid[y][CONFIG.LANES.DIVIDER + 1] = STYLES.TRAFFIC + "║" + STYLES.RESET;
            this.grid[y][CONFIG.LANES.TRACKS + 1] = STYLES.TRACKS + "║" + STYLES.RESET;
            this.grid[y][CONFIG.LANES.TRACKS + 5] = STYLES.TRACKS + "║" + STYLES.RESET;

            if (y % 3 === 0) {
              this.grid[y][CONFIG.LANES.BIKE - 1] = STYLES.TRAFFIC + " " + STYLES.RESET;
            }

            for (let x = CONFIG.LANES.SIDEWALK; x < CONFIG.LANES.SHOPS; x++) {
              this.grid[y][x] = STYLES.SIDEWALK + " " + STYLES.RESET;
            }
          }
        }

        drawShops() {
          let currentY = 0; // Track Y position for the next shop

          while (currentY < CONFIG.GAME.HEIGHT) {
            const shop = TORONTO_SHOPS[Math.floor(Math.random() * TORONTO_SHOPS.length)];
            const color = COLORS.BUILDINGS[Math.floor(Math.random() * COLORS.BUILDINGS.length)];
            const shopStyle = `<span style='color: ${color}'>`;

            // Determine shop dimensions
            const shopHeight = shop.art.length;
            const shopWidth = shop.art[0].length;

            // Place shop art in grid
            shop.art.forEach((line, i) => {
              const y = currentY + i;
              if (y < CONFIG.GAME.HEIGHT) {
                for (let x = 0; x < line.length; x++) {
                  const screenX = CONFIG.LANES.SHOPS + x;
                  if (screenX < CONFIG.GAME.WIDTH) {
                    this.grid[y][screenX] = shopStyle + line[x] + STYLES.RESET;
                  }
                }
              }
            });

            // Create and store shop hitbox based on dimensions
            const shopHitbox = {
              x: CONFIG.LANES.SHOPS,
              y: currentY,
              width: shopWidth,
              height: shopHeight,
            };
            this.collisionManager.addShopHitbox(shopHitbox); // Store hitbox in collision manager

            // Update currentY to place the next shop below the current one
            currentY += shopHeight;
          }
        }

        drawEntity(entity, style) {
          if (entity.y + entity.height >= 0 && entity.y < CONFIG.GAME.HEIGHT) {
            entity.art.forEach((line, i) => {
              if (entity.y + i >= 0 && entity.y + i < CONFIG.GAME.HEIGHT) {
                for (let x = 0; x < line.length; x++) {
                  if (line[x] !== " " && entity.x + x >= 0 && entity.x + x < CONFIG.GAME.WIDTH) {
                    this.grid[Math.floor(entity.y + i)][entity.x + x] = style + line[x] + STYLES.RESET;
                  }
                }
              }
            });
          }
        }

        drawEntities() {
          this.obstacleManager.getAllObjects().forEach((entity) => {
            if (entity.type === "PEDESTRIAN") {
              this.drawEntity(entity, STYLES.SIDEWALK);
            } else {
              this.drawEntity(entity, entity.color);
            }
          });
        }

        drawPlayer() {
          if (this.state.isDead && this.state.deathAnimation < 10) {
            ENTITIES.EXPLOSION.art.forEach((line, i) => {
              for (let x = 0; x < line.length; x++) {
                if (this.deathY + i < CONFIG.GAME.HEIGHT) {
                  this.grid[this.deathY + i][this.deathX + x] = STYLES.TRAFFIC + line[x] + STYLES.RESET;
                }
              }
            });
          } else if (!this.state.isDead) {
            const bikeY = this.state.isJumping ? CONFIG.GAME.CYCLIST_Y - 1 : CONFIG.GAME.CYCLIST_Y;
            ENTITIES.BIKE.art.forEach((line, i) => {
              for (let x = 0; x < line.length; x++) {
                if (line[x] !== " ") {
                  this.grid[bikeY + i][this.state.currentLane + x] = STYLES.BIKE + line[x] + STYLES.RESET;
                }
              }
            });
          }
        }

        drawHitboxes() {
          // Player hitbox
          const playerHitbox = {
            x: this.state.currentLane,
            y: this.state.isJumping ? CONFIG.GAME.CYCLIST_Y - 1 : CONFIG.GAME.CYCLIST_Y,
            width: ENTITIES.BIKE.width,
            height: ENTITIES.BIKE.height,
          };
          this.drawHitbox(playerHitbox, " ", "rgb(255, 0, 0)");

          // Get all obstacles from obstacle manager
          this.obstacleManager.getAllObjects().forEach((obstacle) => {
            if (obstacle && obstacle.hitbox) {
              this.drawHitbox(obstacle.hitbox, " ", "rgb(0, 255, 0)");

              // Check for door hitbox
              if (obstacle.type === "PARKED" && obstacle.doorState > 0 && obstacle.doorHitbox) {
                this.drawHitbox(obstacle.doorHitbox, " ", "rgb(255, 0, 255)");
              }
            }
          });
        }

        drawHitbox(hitbox, char, color) {
          // Add safety checks
          if (
            !hitbox ||
            typeof hitbox.x === "undefined" ||
            typeof hitbox.y === "undefined" ||
            typeof hitbox.width === "undefined" ||
            typeof hitbox.height === "undefined"
          ) {
            return;
          }

          const yStart = Math.max(0, Math.floor(hitbox.y));
          const yEnd = Math.min(this.grid.length, Math.floor(hitbox.y + hitbox.height));
          const xStart = Math.max(0, Math.floor(hitbox.x));
          const xEnd = Math.min(this.grid[0].length, Math.floor(hitbox.x + hitbox.width));

          // Convert color to rgba for transparency
          const rgba = color.replace(")", ", 0.3)").replace("rgb", "rgba");

          for (let y = yStart; y < yEnd; y++) {
            for (let x = xStart; x < xEnd; x++) {
              if (this.grid[y] && this.grid[y][x]) {
                // Create a span with a semi-transparent background color
                this.grid[y][x] = `<span style='background-color: ${rgba}'>${this.grid[y][x]}</span>`;
              }
            }
          }
        }
        die(reason) {
          this.state.isDead = true;
          this.deathX = this.state.currentLane;
          this.deathY = CONFIG.GAME.CYCLIST_Y;

          // Add the cute faces array
          const cuteDeathFaces = [
            `(×﹏×)`,
            `(｡×﹏×｡)`,
            `(✖╭╮✖)`,
            `(;×_×;)`,
            `(｡T ω T｡)`,
            `(✿×﹏×✿)`,
            `(╥ω╥)`,
            `( ⚈̥̥̥̥̥́⌢⚈̥̥̥̥̥̀)`,
            `(ಥ﹏ಥ)`,
            `(T⌓T)`,
            `(｡•́︿•̀｡)`,
            `(｡╥﹏╥｡)`,
            `(✖︿✖)`,
            `(o︵o)`,
            `(｡•́︵•̀｡)`,
            `(✿｡︿｡✿)`,
            `(｡•́_•̀｡)`,
            `(T_T)`,
            `(╯︵╰,)`,
            `(っ- ‸ – ς)`,
          ];

          const flashScreen = () => {
            document.getElementById("game-screen").style.backgroundColor = "#FF0000";

            setTimeout(() => {
              document.getElementById("game-screen").style.backgroundColor = "#000000";

              setTimeout(() => {
                document.getElementById("game-screen").style.backgroundColor = "#222";
              }, 100);
            }, 100);
          };

          flashScreen();

          const randomMessage = this.getRandomDeathMessage(reason);
          const randomFace = cuteDeathFaces[Math.floor(Math.random() * cuteDeathFaces.length)];

          const messageEl = document.getElementById("mainMessageBox");

          messageEl.innerHTML = `
                          <span class="message-reason">${randomMessage.reason}</span><br /><br />
                          ${randomMessage.funny}<br /><br /><span class="cute-face">${randomFace}</span>
                        `;

          messageEl.style.display = "block";

          setTimeout(() => {
            messageEl.classList.remove("show-message");
            this.restart();
          }, 3000);
        }

        getRandomDeathMessage(type) {
          const messages = MESSAGES.DEATH[type];

          // Check if messages array exists; if not, use a default message
          if (!messages || messages.length === 0) {
            return {
              reason: "X X!",
              funny: "Sometimes things just happen",
            };
          }
          return messages[Math.floor(Math.random() * messages.length)];
        }

        restart() {
          this.collisionManager = new CollisionManager(CONFIG);
          this.obstacleManager = new ObstacleManager(CONFIG, this.collisionManager);
          this.initializeState();
          this.start();
          document.getElementById("mainMessageBox").textContent = MESSAGES.GAME.START;
        }

        handleDeathAnimation() {
          this.state.deathAnimation++;
          if (this.state.deathAnimation > 10) {
            this.state.isPlaying = false;
            clearInterval(this.gameLoop);
            return;
          }
          this.render();
        }

        updateScore() {
          this.state.score++;
          document.getElementById("time-alive").textContent = `STAY ALIVE? ${this.state.score}`;
          this.state.speed = Math.max(this.state.speed * CONFIG.GAME.SPEED_DECREASE_RATE, CONFIG.GAME.MIN_SPEED);

          clearInterval(this.gameLoop);
          this.gameLoop = setInterval(() => this.update(), this.state.speed);
        }
      }

      /////////////////////////////////////////
      /////////////////////////////////////////
      ///////////SETTINGS WINDOW /////////////
      ////////////////////////////////////////
      ////////////////////////////////////////

      // Toggle settings window visibility with "D" key
      document.addEventListener("keydown", (e) => {
        if (e.key.toLowerCase() === "d") {
          const settingsWindow = document.getElementById("settings-window");
          settingsWindow.style.display = settingsWindow.style.display === "none" ? "block" : "none";
        }
      });

      // Update configuration values and display value on input change
      document.getElementById("pedestrian-speed").addEventListener("input", (e) => {
        CONFIG.PEDESTRIAN.SPEED = parseFloat(e.target.value);
        document.getElementById("pedestrian-speed-value").textContent = e.target.value;
      });

      document.getElementById("streetcar-spawn-rate").addEventListener("input", (e) => {
        CONFIG.SPAWN_RATES.STREETCAR = parseFloat(e.target.value);
        document.getElementById("streetcar-spawn-rate-value").textContent = e.target.value;
      });

      document.getElementById("oncoming-car-spawn-rate").addEventListener("input", (e) => {
        CONFIG.SPAWN_RATES.ONCOMING_CAR = parseFloat(e.target.value);
        document.getElementById("oncoming-car-spawn-rate-value").textContent = e.target.value;
      });

      document.getElementById("parked-car-spawn-rate").addEventListener("input", (e) => {
        CONFIG.SPAWN_RATES.PARKED_CAR = parseFloat(e.target.value);
        document.getElementById("parked-car-spawn-rate-value").textContent = e.target.value;
      });

      document.getElementById("streetcar-lane-car-spawn-rate").addEventListener("input", (e) => {
        CONFIG.SPAWN_RATES.STREETCAR_LANE_CAR = parseFloat(e.target.value);
        document.getElementById("streetcar-lane-car-spawn-rate-value").textContent = e.target.value;
      });

      document.getElementById("pedestrian-spawn-rate").addEventListener("input", (e) => {
        CONFIG.SPAWN_RATES.PEDESTRIAN = parseFloat(e.target.value);
        document.getElementById("pedestrian-spawn-rate-value").textContent = e.target.value;
      });

      document.getElementById("initial-speed").addEventListener("input", (e) => {
        CONFIG.GAME.INITIAL_SPEED = parseInt(e.target.value);
        document.getElementById("initial-speed-value").textContent = e.target.value;
      });

      document.getElementById("min-speed").addEventListener("input", (e) => {
        CONFIG.GAME.MIN_SPEED = parseInt(e.target.value);
        document.getElementById("min-speed-value").textContent = e.target.value;
      });

      document.getElementById("speed-decrease-rate").addEventListener("input", (e) => {
        CONFIG.GAME.SPEED_DECREASE_RATE = parseFloat(e.target.value);
        document.getElementById("speed-decrease-rate-value").textContent = e.target.value;
      });

      // Vehicle Gap Controls
      document.getElementById("streetcar-gap").addEventListener("input", (e) => {
        CONFIG.SAFE_DISTANCE.STREETCAR = parseInt(e.target.value);
        document.getElementById("streetcar-gap-value").textContent = e.target.value;
      });

      document.getElementById("lane-car-gap").addEventListener("input", (e) => {
        CONFIG.SAFE_DISTANCE.STREETCAR_LANE_CAR = parseInt(e.target.value);
        document.getElementById("lane-car-gap-value").textContent = e.target.value;
      });

      document.getElementById("oncoming-car-gap").addEventListener("input", (e) => {
        CONFIG.SAFE_DISTANCE.ONCOMING_CAR = parseInt(e.target.value);
        document.getElementById("oncoming-car-gap-value").textContent = e.target.value;
      });

      // Lane Width and Cyclist Speed Controls
      document.getElementById("lane-width").addEventListener("input", (e) => {
        CONFIG.GAME.WIDTH = parseInt(e.target.value);
        document.getElementById("lane-width-value").textContent = e.target.value;
      });

      document.getElementById("cyclist-speed").addEventListener("input", (e) => {
        game.state.movementSpeed = parseInt(e.target.value);
        document.getElementById("cyclist-speed-value").textContent = e.target.value;
      });

      // Initialize game
      const game = new LoserLane();
    </script>
    <script src="assets.js"></script>
    <script src="messages.js"></script>
    <script src="config.js"></script>
  </body>
</html>
